{"repository": {"owner": {"login": "google"}, "name": "guava", "forkCount": 9075, "stargazerCount": 40615, "createdAt": "2014-05-29T16:23:17Z", "updatedAt": "2021-03-18T06:45:20Z", "repositoryTopics": {"edges": [{"node": {"topic": {"name": "guava"}}}, {"node": {"topic": {"name": "java"}}}]}, "languages": {"edges": [{"node": {"name": "Java"}}, {"node": {"name": "CSS"}}, {"node": {"name": "Shell"}}, {"node": {"name": "JavaScript"}}]}, "primaryLanguage": {"name": "Java"}}, "id": "MDU6SXNzdWUyNTQwNTU3NTg=", "number": 2930, "author": {"login": "xenoterracide"}, "title": "allow use of a weak hashmap in the EventBus for listeners", "body": "The EventBus currently requires you to unregister/manually garbage collect. Making it responsible for Listener lifecycles. We have a problem where we have to manually deregister in order to avoid memory leaks, but the only hooks for us to do this also create subtle bugs. What'd we'd really like is for listeners to be stored as weak keys, so if the listener could otherwise be garbage collected it would be. This way the eventbus can be \"global\" or \"session\" and you can have listeners that come and go. If you need persistent listeners you can use your DI system, whether that be Spring, Guice, etc.\r\n\r\nhttps://github.com/bennidi/mbassador is an eventbus that works this way, and there is some consideration on switching to it on our part, but the long term stability of that project is questionable.\r\n\r\nwhat I would suggest for backwards compatibility is storing the listeners in [your own cache](https://github.com/google/guava/wiki/CachesExplained#eviction), and then adding a constructor or static method that allows the creation of an eventbus with a custom `CacheBuilder` allowing us to say `CacheBuilder.weakKeys(...)` or whatever. It's possible you could go for much less flexible and simply make it a boolean or something.", "bodyHTML": "<p>The EventBus currently requires you to unregister/manually garbage collect. Making it responsible for Listener lifecycles. We have a problem where we have to manually deregister in order to avoid memory leaks, but the only hooks for us to do this also create subtle bugs. What'd we'd really like is for listeners to be stored as weak keys, so if the listener could otherwise be garbage collected it would be. This way the eventbus can be \"global\" or \"session\" and you can have listeners that come and go. If you need persistent listeners you can use your DI system, whether that be Spring, Guice, etc.</p>\n<p><a href=\"https://github.com/bennidi/mbassador\">https://github.com/bennidi/mbassador</a> is an eventbus that works this way, and there is some consideration on switching to it on our part, but the long term stability of that project is questionable.</p>\n<p>what I would suggest for backwards compatibility is storing the listeners in <a href=\"https://github.com/google/guava/wiki/CachesExplained#eviction\">your own cache</a>, and then adding a constructor or static method that allows the creation of an eventbus with a custom <code>CacheBuilder</code> allowing us to say <code>CacheBuilder.weakKeys(...)</code> or whatever. It's possible you could go for much less flexible and simply make it a boolean or something.</p>", "bodyText": "The EventBus currently requires you to unregister/manually garbage collect. Making it responsible for Listener lifecycles. We have a problem where we have to manually deregister in order to avoid memory leaks, but the only hooks for us to do this also create subtle bugs. What'd we'd really like is for listeners to be stored as weak keys, so if the listener could otherwise be garbage collected it would be. This way the eventbus can be \"global\" or \"session\" and you can have listeners that come and go. If you need persistent listeners you can use your DI system, whether that be Spring, Guice, etc.\nhttps://github.com/bennidi/mbassador is an eventbus that works this way, and there is some consideration on switching to it on our part, but the long term stability of that project is questionable.\nwhat I would suggest for backwards compatibility is storing the listeners in your own cache, and then adding a constructor or static method that allows the creation of an eventbus with a custom CacheBuilder allowing us to say CacheBuilder.weakKeys(...) or whatever. It's possible you could go for much less flexible and simply make it a boolean or something.", "assignees": {"edges": []}, "createdAt": "2017-08-30T16:11:40Z", "closed": true, "closedAt": "2019-08-08T10:27:54Z", "lastEditedAt": "2017-08-30T16:32:15Z", "publishedAt": "2017-08-30T16:11:40Z", "comments": {"totalCount": 3, "edges": [{"node": {"id": "MDEyOklzc3VlQ29tbWVudDMyNjA0NDcwMA==", "author": {"login": "perceptron8"}, "body": "Duplicate of #807? See https://groups.google.com/forum/#!topic/guava-discuss/fEbuAmk2VFE also.", "bodyText": "Duplicate of #807? See https://groups.google.com/forum/#!topic/guava-discuss/fEbuAmk2VFE also.", "bodyHTML": "<p>Duplicate of <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"47421109\" data-permission-text=\"Title is private\" data-url=\"https://github.com/google/guava/issues/807\" data-hovercard-type=\"issue\" data-hovercard-url=\"/google/guava/issues/807/hovercard\" href=\"https://github.com/google/guava/issues/807\">#807</a>? See <a rel=\"nofollow\" href=\"https://groups.google.com/forum/#!topic/guava-discuss/fEbuAmk2VFE\">https://groups.google.com/forum/#!topic/guava-discuss/fEbuAmk2VFE</a> also.</p>", "createdAt": "2017-08-30T16:25:43Z", "publishedAt": "2017-08-30T16:25:43Z", "lastEditedAt": null, "updatedAt": "2017-08-30T16:25:43Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 1764, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Duplicate of #807?", "sentSegmented": ["duplicate", "of", "807"], "sentSegmentedWithoutStops": ["duplicate", "807"], "sentSegmentedWithoutStopsStemmed": ["duplic", "807"]}, {"number": 1765, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "See https://groups.google.com/forum/#!topic/guava-discuss/fEbuAmk2VFE also.", "sentSegmented": ["see", "https", "//groups.google.com/forum/", "topic/guava-discuss/febuamk2vfe", "also"], "sentSegmentedWithoutStops": ["see", "https", "//groups.google.com/forum/", "topic/guava-discuss/febuamk2vfe", "also"], "sentSegmentedWithoutStopsStemmed": ["see", "http", "//groups.google.com/forum/", "topic/guava-discuss/febuamk2vf", "also"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDMyNjA0NjU0NA==", "author": {"login": "xenoterracide"}, "body": "probably a dupe of #807, though I don't agree with the solution proposed there (and it's hard to follow). The problem all comes down to having listeners that have a shorter lifecycle than the eventbus, and that don't have good hooks of their own to deregister.", "bodyText": "probably a dupe of #807, though I don't agree with the solution proposed there (and it's hard to follow). The problem all comes down to having listeners that have a shorter lifecycle than the eventbus, and that don't have good hooks of their own to deregister.", "bodyHTML": "<p>probably a dupe of <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"47421109\" data-permission-text=\"Title is private\" data-url=\"https://github.com/google/guava/issues/807\" data-hovercard-type=\"issue\" data-hovercard-url=\"/google/guava/issues/807/hovercard\" href=\"https://github.com/google/guava/issues/807\">#807</a>, though I don't agree with the solution proposed there (and it's hard to follow). The problem all comes down to having listeners that have a shorter lifecycle than the eventbus, and that don't have good hooks of their own to deregister.</p>", "createdAt": "2017-08-30T16:32:35Z", "publishedAt": "2017-08-30T16:32:35Z", "lastEditedAt": "2017-08-30T16:33:01Z", "updatedAt": "2017-08-30T16:33:01Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 1766, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "probably a dupe of #807, though I don't agree with the solution proposed there (and it's hard to follow).", "sentSegmented": ["probably", "a", "dupe", "of", "807", "though", "i", "do", "n't", "agree", "with", "the", "solution", "proposed", "there", "and", "it", "'s", "hard", "to", "follow"], "sentSegmentedWithoutStops": ["probably", "dupe", "807", "though", "n't", "agree", "solution", "proposed", "'s", "hard", "follow"], "sentSegmentedWithoutStopsStemmed": ["probabl", "dupe", "807", "though", "n't", "agre", "solut", "propos", "'s", "hard", "follow"]}, {"number": 1767, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "The problem all comes down to having listeners that have a shorter lifecycle than the eventbus, and that don't have good hooks of their own to deregister.", "sentSegmented": ["the", "problem", "all", "comes", "down", "to", "having", "listeners", "that", "have", "a", "shorter", "lifecycle", "than", "the", "eventbus", "and", "that", "do", "n't", "have", "good", "hooks", "of", "their", "own", "to", "deregister"], "sentSegmentedWithoutStops": ["problem", "comes", "listeners", "shorter", "lifecycle", "eventbus", "n't", "good", "hooks", "deregister"], "sentSegmentedWithoutStopsStemmed": ["problem", "come", "listen", "shorter", "lifecycl", "eventbu", "n't", "good", "hook", "deregist"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDUxOTQ2MjQxOA==", "author": {"login": "ronshapiro"}, "body": "Closing this in favor of the duplicate issue", "bodyText": "Closing this in favor of the duplicate issue", "bodyHTML": "<p>Closing this in favor of the duplicate issue</p>", "createdAt": "2019-08-08T10:27:54Z", "publishedAt": "2019-08-08T10:27:54Z", "lastEditedAt": null, "updatedAt": "2019-08-08T10:27:54Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 1768, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Closing this in favor of the duplicate issue", "sentSegmented": ["closing", "this", "in", "favor", "of", "the", "duplicate", "issue"], "sentSegmentedWithoutStops": ["closing", "favor", "duplicate", "issue"], "sentSegmentedWithoutStopsStemmed": ["close", "favor", "duplic", "issu"]}]}}], "pageInfo": {"endCursor": "Y3Vyc29yOnYyOpHOHvZeEg==", "hasNextPage": false}}, "labels": {"edges": [{"node": {"createdAt": "2014-10-31T17:57:27Z", "name": "package=eventbus"}}, {"node": {"createdAt": "2014-10-31T17:15:09Z", "name": "type=enhancement"}}]}, "milestone": null, "reactions": {"edges": [{"node": {"content": "THUMBS_UP", "createdAt": "2017-12-20T14:30:17Z"}}, {"node": {"content": "THUMBS_UP", "createdAt": "2018-02-08T19:33:30Z"}}]}, "state": "CLOSED", "titleSegmented": ["allow", "use", "of", "a", "weak", "hashmap", "in", "the", "eventbus", "for", "listeners"], "titleSegmentedWithoutStops": ["allow", "use", "weak", "hashmap", "eventbus", "listeners"], "titleSegmentedWithoutStopsStemmed": ["allow", "use", "weak", "hashmap", "eventbu", "listen"], "bodyParsed": [{"number": 1755, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "The EventBus currently requires you to unregister/manually garbage collect.", "sentSegmented": ["the", "eventbus", "currently", "requires", "you", "to", "unregister/manually", "garbage", "collect"], "sentSegmentedWithoutStops": ["eventbus", "currently", "requires", "unregister/manually", "garbage", "collect"], "sentSegmentedWithoutStopsStemmed": ["eventbu", "current", "requir", "unregister/manu", "garbag", "collect"]}, {"number": 1756, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Making it responsible for Listener lifecycles.", "sentSegmented": ["making", "it", "responsible", "for", "listener", "lifecycles"], "sentSegmentedWithoutStops": ["making", "responsible", "listener", "lifecycles"], "sentSegmentedWithoutStopsStemmed": ["make", "respons", "listen", "lifecycl"]}, {"number": 1757, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "We have a problem where we have to manually deregister in order to avoid memory leaks, but the only hooks for us to do this also create subtle bugs.", "sentSegmented": ["we", "have", "a", "problem", "where", "we", "have", "to", "manually", "deregister", "in", "order", "to", "avoid", "memory", "leaks", "but", "the", "only", "hooks", "for", "us", "to", "do", "this", "also", "create", "subtle", "bugs"], "sentSegmentedWithoutStops": ["problem", "manually", "deregister", "order", "avoid", "memory", "leaks", "hooks", "us", "also", "create", "subtle", "bugs"], "sentSegmentedWithoutStopsStemmed": ["problem", "manual", "deregist", "order", "avoid", "memori", "leak", "hook", "us", "also", "creat", "subtl", "bug"]}, {"number": 1758, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "What'd we'd really like is for listeners to be stored as weak keys, so if the listener could otherwise be garbage collected it would be.", "sentSegmented": ["what", "'d", "we", "'d", "really", "like", "is", "for", "listeners", "to", "be", "stored", "as", "weak", "keys", "so", "if", "the", "listener", "could", "otherwise", "be", "garbage", "collected", "it", "would", "be"], "sentSegmentedWithoutStops": ["'d", "'d", "really", "like", "listeners", "stored", "weak", "keys", "listener", "could", "otherwise", "garbage", "collected", "would"], "sentSegmentedWithoutStopsStemmed": ["'d", "'d", "realli", "like", "listen", "store", "weak", "key", "listen", "could", "otherwis", "garbag", "collect", "would"]}, {"number": 1759, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "This way the eventbus can be \"global\" or \"session\" and you can have listeners that come and go.", "sentSegmented": ["this", "way", "the", "eventbus", "can", "be", "global", "or", "session", "and", "you", "can", "have", "listeners", "that", "come", "and", "go"], "sentSegmentedWithoutStops": ["way", "eventbus", "global", "session", "listeners", "come", "go"], "sentSegmentedWithoutStopsStemmed": ["way", "eventbu", "global", "session", "listen", "come", "go"]}, {"number": 1760, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "If you need persistent listeners you can use your DI system, whether that be Spring, Guice, etc.", "sentSegmented": ["if", "you", "need", "persistent", "listeners", "you", "can", "use", "your", "di", "system", "whether", "that", "be", "spring", "guice", "etc"], "sentSegmentedWithoutStops": ["need", "persistent", "listeners", "use", "di", "system", "whether", "spring", "guice", "etc"], "sentSegmentedWithoutStopsStemmed": ["need", "persist", "listen", "use", "di", "system", "whether", "spring", "guic", "etc"]}, {"number": 1761, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "https://github.com/bennidi/mbassador is an eventbus that works this way, and there is some consideration on switching to it on our part, but the long term stability of that project is questionable.", "sentSegmented": ["https", "//github.com/bennidi/mbassador", "is", "an", "eventbus", "that", "works", "this", "way", "and", "there", "is", "some", "consideration", "on", "switching", "to", "it", "on", "our", "part", "but", "the", "long", "term", "stability", "of", "that", "project", "is", "questionable"], "sentSegmentedWithoutStops": ["https", "//github.com/bennidi/mbassador", "eventbus", "works", "way", "consideration", "switching", "part", "long", "term", "stability", "project", "questionable"], "sentSegmentedWithoutStopsStemmed": ["http", "//github.com/bennidi/mbassador", "eventbu", "work", "way", "consider", "switch", "part", "long", "term", "stabil", "project", "question"]}, {"number": 1762, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "what I would suggest for backwards compatibility is storing the listeners in your own cache, and then adding a constructor or static method that allows the creation of an eventbus with a custom CacheBuilder allowing us to say CacheBuilder.weakKeys(...) or whatever.", "sentSegmented": ["what", "i", "would", "suggest", "for", "backwards", "compatibility", "is", "storing", "the", "listeners", "in", "your", "own", "cache", "and", "then", "adding", "a", "constructor", "or", "static", "method", "that", "allows", "the", "creation", "of", "an", "eventbus", "with", "a", "custom", "cachebuilder", "allowing", "us", "to", "say", "cachebuilder.weakkeys", "or", "whatever"], "sentSegmentedWithoutStops": ["would", "suggest", "backwards", "compatibility", "storing", "listeners", "cache", "adding", "constructor", "static", "method", "allows", "creation", "eventbus", "custom", "cachebuilder", "allowing", "us", "say", "cachebuilder.weakkeys", "whatever"], "sentSegmentedWithoutStopsStemmed": ["would", "suggest", "backward", "compat", "store", "listen", "cach", "ad", "constructor", "static", "method", "allow", "creation", "eventbu", "custom", "cachebuild", "allow", "us", "say", "cachebuilder.weakkey", "whatev"]}, {"number": 1763, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "It's possible you could go for much less flexible and simply make it a boolean or something.", "sentSegmented": ["it", "'s", "possible", "you", "could", "go", "for", "much", "less", "flexible", "and", "simply", "make", "it", "a", "boolean", "or", "something"], "sentSegmentedWithoutStops": ["'s", "possible", "could", "go", "much", "less", "flexible", "simply", "make", "boolean", "something"], "sentSegmentedWithoutStopsStemmed": ["'s", "possibl", "could", "go", "much", "less", "flexibl", "simpli", "make", "boolean", "someth"]}]}