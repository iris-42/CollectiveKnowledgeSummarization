{"repository": {"owner": {"login": "airbnb"}, "name": "lottie-android", "forkCount": 4927, "stargazerCount": 30825, "createdAt": "2016-10-06T22:42:42Z", "updatedAt": "2021-03-18T06:50:29Z", "repositoryTopics": {"edges": [{"node": {"topic": {"name": "animation"}}}, {"node": {"topic": {"name": "android"}}}, {"node": {"topic": {"name": "lottie"}}}, {"node": {"topic": {"name": "airbnb"}}}, {"node": {"topic": {"name": "after-effects"}}}]}, "languages": {"edges": [{"node": {"name": "Java"}}, {"node": {"name": "Kotlin"}}, {"node": {"name": "Shell"}}, {"node": {"name": "JavaScript"}}]}, "primaryLanguage": {"name": "Java"}}, "id": "MDU6SXNzdWU0Njg4ODE2MDA=", "number": 1324, "author": {"login": "YuriiTsap"}, "title": "RecycleView, wasAnimatingWhenDetached isn't set to false when view is attached", "body": "We have a related [issue](https://github.com/airbnb/lottie-android/issues/1322) created few hours ago.\r\nBut the main issue isn't highlighted/described enough inside of the ticket.\r\n\r\n**_Let's start:_** \r\nI'm using `LottieAnimationView.java` inside `RecyclerView.java`. In my code every third item has an animation running, I'm operating with a dataset containing 60 items.\r\nWhen `LottieAnimationView.java` is playing an animation and user starts scrolling  we receive a `onDetachedFromWindow()` (_in case if view scroll offset is big enough_).\r\n```\r\n@Override \r\nprotected void onDetachedFromWindow() {\r\n    if (isAnimating()) {\r\n      cancelAnimation();\r\n      wasAnimatingWhenDetached = true;\r\n    }\r\n    super.onDetachedFromWindow();\r\n  }\r\n```\r\nHere we are setting `wasAnimatingWhenDetached` to `true`. Afterwards, when user scrolls again and returns to the same item - onAttachedToWindow() callback is called:\r\n```\r\n@Override protected void onAttachedToWindow() {\r\n    super.onAttachedToWindow();\r\n    if (autoPlay || wasAnimatingWhenDetached) {\r\n      playAnimation();\r\n      // Autoplay from xml should only apply once.\r\n      autoPlay = false;\r\n    }\r\n    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {\r\n      // This is needed to mimic newer platform behavior.\r\n      // https://stackoverflow.com/a/53625860/715633\r\n      onVisibilityChanged(this, getVisibility());\r\n    }\r\n  }\r\n```\r\nIn this callback we are relying on `wasAnimatingWhenDetached` and in our case we will play animation which wasn't finished. Until now everything was pretty ok, we are restarting animation which wasn't finished - pretty logical. But we aren't setting `wasAnimatingWhenDetached` flag to `false` - and that has some side effects. \r\nIn example we scroll back and forth, basically just returning to the same item - and it will again go through `onDetachedFromWindow()` && `onAttachedToWindow()`callbacks. And when the `onAttachedToWindow()` callback will be triggered we will re-run the animation again, evenif it was finished, which isn't the desired behavior(_at least as I see it_). That will happen because `wasAnimatingWhenDetached` isn't set to false in `onAttachedToWindow()` callback. Here is an example how it works in real-life(almost) [app](https://drive.google.com/open?id=1j-2ct6f5mWlC8lO7bT1vq0svtjf9riM2). Video is attached as link on google drive as Github doesn't supports mp4.\r\nSo, as you can see I have the bells animation which should be played only once. At first I want to show normal/desired flow:\r\n\r\n- User scrolls to an item with animation\r\n- Animation plays till it is finished\r\n- User scrolls back and forth but animation doesn't restarts\r\n\r\nAfterwards I wanna show wrong flow:\r\n\r\n- User scrolls to an item with animation\r\n- Animation starts\r\n- User starts scrolling and animation is cancelled\r\n- User scrolls back to that animation item and animation re-runs and is finished. We end up in finished animation state.\r\n- Every next time user scrolls back and forth - animation re-runs. **That is not desired behavior(IMHO).**\r\n\r\nI've cloned lottie project and imported it as module to mine project. I have an idea how that could be fixed(if thats a bug of course). We can add following line to `onAttachedToWindow()` callback:\r\n\r\n```\r\n@Override \r\nprotected void onAttachedToWindow() {\r\n    super.onAttachedToWindow();\r\n    if (autoPlay || wasAnimatingWhenDetached) {\r\n      playAnimation();\r\n      // Autoplay from xml should only apply once.\r\n      autoPlay = false;\r\n     // this one line could be used to reset our flag\r\n      wasAnimatingWhenDetached = false;\r\n    }\r\n    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {\r\n      // This is needed to mimic newer platform behavior.\r\n      // https://stackoverflow.com/a/53625860/715633\r\n      onVisibilityChanged(this, getVisibility());\r\n    }\r\n  }\r\n\r\n```\r\nI haven't analyzed other cases, where this fix could create issues. But I'm almost sure other cases do not exist. Anyway it would be great to hear feedback or explanation on that.\r\nAnimation JSON file attached:\r\n[ringing_bell.json.zip](https://github.com/airbnb/lottie-android/files/3399251/ringing_bell.json.zip)\r\n\r\n\r\n", "bodyHTML": "<p>We have a related <a href=\"https://github.com/airbnb/lottie-android/issues/1322\" data-hovercard-type=\"issue\" data-hovercard-url=\"/airbnb/lottie-android/issues/1322/hovercard\">issue</a> created few hours ago.<br>\nBut the main issue isn't highlighted/described enough inside of the ticket.</p>\n<p><strong><em>Let's start:</em></strong><br>\nI'm using <code>LottieAnimationView.java</code> inside <code>RecyclerView.java</code>. In my code every third item has an animation running, I'm operating with a dataset containing 60 items.<br>\nWhen <code>LottieAnimationView.java</code> is playing an animation and user starts scrolling  we receive a <code>onDetachedFromWindow()</code> (<em>in case if view scroll offset is big enough</em>).</p>\n<pre><code>@Override \nprotected void onDetachedFromWindow() {\n    if (isAnimating()) {\n      cancelAnimation();\n      wasAnimatingWhenDetached = true;\n    }\n    super.onDetachedFromWindow();\n  }\n</code></pre>\n<p>Here we are setting <code>wasAnimatingWhenDetached</code> to <code>true</code>. Afterwards, when user scrolls again and returns to the same item - onAttachedToWindow() callback is called:</p>\n<pre><code>@Override protected void onAttachedToWindow() {\n    super.onAttachedToWindow();\n    if (autoPlay || wasAnimatingWhenDetached) {\n      playAnimation();\n      // Autoplay from xml should only apply once.\n      autoPlay = false;\n    }\n    if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) {\n      // This is needed to mimic newer platform behavior.\n      // https://stackoverflow.com/a/53625860/715633\n      onVisibilityChanged(this, getVisibility());\n    }\n  }\n</code></pre>\n<p>In this callback we are relying on <code>wasAnimatingWhenDetached</code> and in our case we will play animation which wasn't finished. Until now everything was pretty ok, we are restarting animation which wasn't finished - pretty logical. But we aren't setting <code>wasAnimatingWhenDetached</code> flag to <code>false</code> - and that has some side effects.<br>\nIn example we scroll back and forth, basically just returning to the same item - and it will again go through <code>onDetachedFromWindow()</code> &amp;&amp; <code>onAttachedToWindow()</code>callbacks. And when the <code>onAttachedToWindow()</code> callback will be triggered we will re-run the animation again, evenif it was finished, which isn't the desired behavior(<em>at least as I see it</em>). That will happen because <code>wasAnimatingWhenDetached</code> isn't set to false in <code>onAttachedToWindow()</code> callback. Here is an example how it works in real-life(almost) <a href=\"https://drive.google.com/open?id=1j-2ct6f5mWlC8lO7bT1vq0svtjf9riM2\" rel=\"nofollow\">app</a>. Video is attached as link on google drive as Github doesn't supports mp4.<br>\nSo, as you can see I have the bells animation which should be played only once. At first I want to show normal/desired flow:</p>\n<ul>\n<li>User scrolls to an item with animation</li>\n<li>Animation plays till it is finished</li>\n<li>User scrolls back and forth but animation doesn't restarts</li>\n</ul>\n<p>Afterwards I wanna show wrong flow:</p>\n<ul>\n<li>User scrolls to an item with animation</li>\n<li>Animation starts</li>\n<li>User starts scrolling and animation is cancelled</li>\n<li>User scrolls back to that animation item and animation re-runs and is finished. We end up in finished animation state.</li>\n<li>Every next time user scrolls back and forth - animation re-runs. <strong>That is not desired behavior(IMHO).</strong></li>\n</ul>\n<p>I've cloned lottie project and imported it as module to mine project. I have an idea how that could be fixed(if thats a bug of course). We can add following line to <code>onAttachedToWindow()</code> callback:</p>\n<pre><code>@Override \nprotected void onAttachedToWindow() {\n    super.onAttachedToWindow();\n    if (autoPlay || wasAnimatingWhenDetached) {\n      playAnimation();\n      // Autoplay from xml should only apply once.\n      autoPlay = false;\n     // this one line could be used to reset our flag\n      wasAnimatingWhenDetached = false;\n    }\n    if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) {\n      // This is needed to mimic newer platform behavior.\n      // https://stackoverflow.com/a/53625860/715633\n      onVisibilityChanged(this, getVisibility());\n    }\n  }\n\n</code></pre>\n<p>I haven't analyzed other cases, where this fix could create issues. But I'm almost sure other cases do not exist. Anyway it would be great to hear feedback or explanation on that.<br>\nAnimation JSON file attached:<br>\n<a href=\"https://github.com/airbnb/lottie-android/files/3399251/ringing_bell.json.zip\">ringing_bell.json.zip</a></p>", "bodyText": "We have a related issue created few hours ago.\nBut the main issue isn't highlighted/described enough inside of the ticket.\nLet's start:\nI'm using LottieAnimationView.java inside RecyclerView.java. In my code every third item has an animation running, I'm operating with a dataset containing 60 items.\nWhen LottieAnimationView.java is playing an animation and user starts scrolling  we receive a onDetachedFromWindow() (in case if view scroll offset is big enough).\n@Override \nprotected void onDetachedFromWindow() {\n    if (isAnimating()) {\n      cancelAnimation();\n      wasAnimatingWhenDetached = true;\n    }\n    super.onDetachedFromWindow();\n  }\n\nHere we are setting wasAnimatingWhenDetached to true. Afterwards, when user scrolls again and returns to the same item - onAttachedToWindow() callback is called:\n@Override protected void onAttachedToWindow() {\n    super.onAttachedToWindow();\n    if (autoPlay || wasAnimatingWhenDetached) {\n      playAnimation();\n      // Autoplay from xml should only apply once.\n      autoPlay = false;\n    }\n    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {\n      // This is needed to mimic newer platform behavior.\n      // https://stackoverflow.com/a/53625860/715633\n      onVisibilityChanged(this, getVisibility());\n    }\n  }\n\nIn this callback we are relying on wasAnimatingWhenDetached and in our case we will play animation which wasn't finished. Until now everything was pretty ok, we are restarting animation which wasn't finished - pretty logical. But we aren't setting wasAnimatingWhenDetached flag to false - and that has some side effects.\nIn example we scroll back and forth, basically just returning to the same item - and it will again go through onDetachedFromWindow() && onAttachedToWindow()callbacks. And when the onAttachedToWindow() callback will be triggered we will re-run the animation again, evenif it was finished, which isn't the desired behavior(at least as I see it). That will happen because wasAnimatingWhenDetached isn't set to false in onAttachedToWindow() callback. Here is an example how it works in real-life(almost) app. Video is attached as link on google drive as Github doesn't supports mp4.\nSo, as you can see I have the bells animation which should be played only once. At first I want to show normal/desired flow:\n\nUser scrolls to an item with animation\nAnimation plays till it is finished\nUser scrolls back and forth but animation doesn't restarts\n\nAfterwards I wanna show wrong flow:\n\nUser scrolls to an item with animation\nAnimation starts\nUser starts scrolling and animation is cancelled\nUser scrolls back to that animation item and animation re-runs and is finished. We end up in finished animation state.\nEvery next time user scrolls back and forth - animation re-runs. That is not desired behavior(IMHO).\n\nI've cloned lottie project and imported it as module to mine project. I have an idea how that could be fixed(if thats a bug of course). We can add following line to onAttachedToWindow() callback:\n@Override \nprotected void onAttachedToWindow() {\n    super.onAttachedToWindow();\n    if (autoPlay || wasAnimatingWhenDetached) {\n      playAnimation();\n      // Autoplay from xml should only apply once.\n      autoPlay = false;\n     // this one line could be used to reset our flag\n      wasAnimatingWhenDetached = false;\n    }\n    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {\n      // This is needed to mimic newer platform behavior.\n      // https://stackoverflow.com/a/53625860/715633\n      onVisibilityChanged(this, getVisibility());\n    }\n  }\n\n\nI haven't analyzed other cases, where this fix could create issues. But I'm almost sure other cases do not exist. Anyway it would be great to hear feedback or explanation on that.\nAnimation JSON file attached:\nringing_bell.json.zip", "assignees": {"edges": []}, "createdAt": "2019-07-16T21:52:34Z", "closed": true, "closedAt": "2019-08-10T20:50:32Z", "lastEditedAt": null, "publishedAt": "2019-07-16T21:52:34Z", "comments": {"edges": [{"node": {"id": "MDEyOklzc3VlQ29tbWVudDUxMzQzMjU5OA==", "author": {"login": "gpeal"}, "body": "@YuriiTsap It would be awesome if you are able to create a failing test case in `FragmentVisibilityTests` and also fix it! The visibility cases are very tricky and I've tried to get good espresso coverage on them since it's very fragile.", "bodyText": "@YuriiTsap It would be awesome if you are able to create a failing test case in FragmentVisibilityTests and also fix it! The visibility cases are very tricky and I've tried to get good espresso coverage on them since it's very fragile.", "bodyHTML": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/YuriiTsap/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/YuriiTsap\">@YuriiTsap</a> It would be awesome if you are able to create a failing test case in <code>FragmentVisibilityTests</code> and also fix it! The visibility cases are very tricky and I've tried to get good espresso coverage on them since it's very fragile.</p>", "createdAt": "2019-07-20T03:44:03Z", "publishedAt": "2019-07-20T03:44:03Z", "lastEditedAt": null, "updatedAt": "2019-07-20T03:44:03Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 3994, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "@YuriiTsap It would be awesome if you are able to create a failing test case in FragmentVisibilityTests and also fix it!", "sentSegmented": ["yuriitsap", "it", "would", "be", "awesome", "if", "you", "are", "able", "to", "create", "a", "failing", "test", "case", "in", "fragmentvisibilitytests", "and", "also", "fix", "it"], "sentSegmentedWithoutStops": ["yuriitsap", "would", "awesome", "able", "create", "failing", "test", "case", "fragmentvisibilitytests", "also", "fix"], "sentSegmentedWithoutStopsStemmed": ["yuriitsap", "would", "awesom", "abl", "creat", "fail", "test", "case", "fragmentvisibilitytest", "also", "fix"]}, {"number": 3995, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "The visibility cases are very tricky and I've tried to get good espresso coverage on them since it's very fragile.", "sentSegmented": ["the", "visibility", "cases", "are", "very", "tricky", "and", "i", "'ve", "tried", "to", "get", "good", "espresso", "coverage", "on", "them", "since", "it", "'s", "very", "fragile"], "sentSegmentedWithoutStops": ["visibility", "cases", "tricky", "'ve", "tried", "get", "good", "espresso", "coverage", "since", "'s", "fragile"], "sentSegmentedWithoutStopsStemmed": ["visibl", "case", "tricki", "'ve", "tri", "get", "good", "espresso", "coverag", "sinc", "'s", "fragil"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDUxMzQ0NjM3Nw==", "author": {"login": "venjirai"}, "body": "In addition to setting `wasAnimatingWhenDetached `to false in `onAttachedToWindow()` to fix the endless animation bug I would also introduce and expose a new flag that can turn restarting animations off altogether. It would then look something like this:\r\n\r\n```\r\n@Override \r\nprotected void onDetachedFromWindow() {\r\n    if (isAnimating()) {\r\n      cancelAnimation();\r\n      if (restartAnimationWhenDetached)\r\n        wasAnimatingWhenDetached = true;\r\n    }\r\n    super.onDetachedFromWindow();\r\n  }\r\n```\r\n", "bodyText": "In addition to setting wasAnimatingWhenDetached to false in onAttachedToWindow() to fix the endless animation bug I would also introduce and expose a new flag that can turn restarting animations off altogether. It would then look something like this:\n@Override \nprotected void onDetachedFromWindow() {\n    if (isAnimating()) {\n      cancelAnimation();\n      if (restartAnimationWhenDetached)\n        wasAnimatingWhenDetached = true;\n    }\n    super.onDetachedFromWindow();\n  }", "bodyHTML": "<p>In addition to setting <code>wasAnimatingWhenDetached </code>to false in <code>onAttachedToWindow()</code> to fix the endless animation bug I would also introduce and expose a new flag that can turn restarting animations off altogether. It would then look something like this:</p>\n<pre><code>@Override \nprotected void onDetachedFromWindow() {\n    if (isAnimating()) {\n      cancelAnimation();\n      if (restartAnimationWhenDetached)\n        wasAnimatingWhenDetached = true;\n    }\n    super.onDetachedFromWindow();\n  }\n</code></pre>", "createdAt": "2019-07-20T07:53:19Z", "publishedAt": "2019-07-20T07:53:19Z", "lastEditedAt": "2019-07-20T07:57:25Z", "updatedAt": "2019-07-20T07:57:25Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 3996, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "In addition to setting wasAnimatingWhenDetached to false in onAttachedToWindow() to fix the endless animation bug I would also introduce and expose a new flag that can turn restarting animations off altogether.", "sentSegmented": ["in", "addition", "to", "setting", "wasanimatingwhendetached", "to", "false", "in", "onattachedtowindow", "to", "fix", "the", "endless", "animation", "bug", "i", "would", "also", "introduce", "and", "expose", "a", "new", "flag", "that", "can", "turn", "restarting", "animations", "off", "altogether"], "sentSegmentedWithoutStops": ["addition", "setting", "wasanimatingwhendetached", "false", "onattachedtowindow", "fix", "endless", "animation", "bug", "would", "also", "introduce", "expose", "new", "flag", "turn", "restarting", "animations", "altogether"], "sentSegmentedWithoutStopsStemmed": ["addit", "set", "wasanimatingwhendetach", "fals", "onattachedtowindow", "fix", "endless", "anim", "bug", "would", "also", "introduc", "expos", "new", "flag", "turn", "restart", "anim", "altogeth"]}, {"number": 3997, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "It would then look something like this:", "sentSegmented": ["it", "would", "then", "look", "something", "like", "this"], "sentSegmentedWithoutStops": ["would", "look", "something", "like"], "sentSegmentedWithoutStopsStemmed": ["would", "look", "someth", "like"]}, {"number": 3998, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "@Override ", "sentSegmented": ["override"], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 3999, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "protected void onDetachedFromWindow() {", "sentSegmented": ["protected", "void", "ondetachedfromwindow"], "sentSegmentedWithoutStops": ["ondetachedfromwindow"], "sentSegmentedWithoutStopsStemmed": ["ondetachedfromwindow"]}, {"number": 4000, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    if (isAnimating()) {", "sentSegmented": ["if", "isanimating"], "sentSegmentedWithoutStops": ["isanimating"], "sentSegmentedWithoutStopsStemmed": ["isanim"]}, {"number": 4001, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "      cancelAnimation();", "sentSegmented": ["cancelanimation"], "sentSegmentedWithoutStops": ["cancelanimation"], "sentSegmentedWithoutStopsStemmed": ["cancelanim"]}, {"number": 4002, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "      if (restartAnimationWhenDetached)", "sentSegmented": ["if", "restartanimationwhendetached"], "sentSegmentedWithoutStops": ["restartanimationwhendetached"], "sentSegmentedWithoutStopsStemmed": ["restartanimationwhendetach"]}, {"number": 4003, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        wasAnimatingWhenDetached = true;", "sentSegmented": ["wasanimatingwhendetached", "true"], "sentSegmentedWithoutStops": ["wasanimatingwhendetached"], "sentSegmentedWithoutStopsStemmed": ["wasanimatingwhendetach"]}, {"number": 4004, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4005, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    super.onDetachedFromWindow();", "sentSegmented": ["super.ondetachedfromwindow"], "sentSegmentedWithoutStops": ["super.ondetachedfromwindow"], "sentSegmentedWithoutStopsStemmed": ["super.ondetachedfromwindow"]}, {"number": 4006, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "  }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDUxNDc3NjYyNw==", "author": {"login": "YuriiTsap"}, "body": "@gpeal Sorry for late reply! I was kind of really far away from civilization and stable internet connection. Sure, I have few ideas how that espresso test could be written. Actually I've spent some time analyzing existing `Tests` inside `FragmentVisibilityTests`. I think my case is similar to `testPausesWhenScrolledOffScreenAndResumesWhenComesBack()` test, so I've taken it as an example and base for building mine. While playing around I've found an interesting thing inside that test. \r\n```\r\n        val scenario = launchFragmentInContainer<TestFragment>()\r\n        onView(isAssignableFrom(RecyclerView::class.java)).check(matches(isDisplayed()))\r\n        scenario.onFragment { assertTrue(it.animationView!!.isAnimating) }\r\n        scenario.onFragment { it.requireView().scrollBy(0, 10_000) }\r\n        scenario.onFragment { assertFalse(it.animationView!!.isAnimating) }\r\n        scenario.onFragment { it.requireView().scrollBy(0, -10_000) }\r\n        scenario.onFragment { assertTrue(it.animationView!!.isAnimating) }\r\n```\r\nIn this code snippet we are scrolling back and forth and verifying that `animationView` restarts animating when it is visible. But that is kinda tricky, as it would be playing animation in any case, because onBindViewHolder()->bindLottieHolder() is called : \r\n\r\n```\r\nprivate fun bindLottieHolder(holder: RecyclerView.ViewHolder) {\r\n                          animationView = holder.itemView as LottieAnimationView\r\n                          (holder.itemView as LottieAnimationView).apply {\r\n                                repeatCount = LottieDrawable.INFINITE\r\n                                setAnimation(R.raw.heart)\r\n                                playAnimation()\r\n                                IdlingRegistry.getInstance().register(LottieIdlingResource(this, name = \"Lottie ${Random.nextFloat()}\"))\r\n                            }\r\n                        }\r\n```\r\n\r\nSo as result `playAnimation()` is called and in any case `animationView!!.isAnimating` will return `true`. Per my mind - this test is testing wrong flow, it should be adjusted. As usually - I could be wrong. \r\nGoing back to mine case - the best way here is to create a PR, it would be easier to review changes. Anyway I'll explain mine approach and solution here:\r\n\r\n- I've introduced new test(sorry for naming, I'm not a naming guru):\r\n```\r\n@Test\r\nfun testPausesWhenScrolledOffScreenAndResumesWhenComesBackWithoutRepeatingWhenFinished() {\r\n\r\n        class TestFragment : Fragment() {\r\n            var animationView: LottieAnimationView? = null\r\n            override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {\r\n                return RecyclerView(requireContext()).apply {\r\n                    layoutManager = LinearLayoutManager(requireContext(), LinearLayoutManager.VERTICAL, false)\r\n                    adapter = object : RecyclerView.Adapter<RecyclerView.ViewHolder>() {\r\n\r\n                        var animationWasPlayed = false\r\n\r\n                        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {\r\n                            return when (viewType) {\r\n                                0 -> object : RecyclerView.ViewHolder(\r\n                                        LottieAnimationView(parent.context)\r\n                                                .apply { id = R.id.animation_view }\r\n                                ) {}\r\n                                else -> object : RecyclerView.ViewHolder(TextView(parent.context)) {}\r\n                            }\r\n                        }\r\n\r\n                        override fun getItemCount(): Int = 1000\r\n\r\n                        override fun getItemViewType(position: Int) = position\r\n\r\n                        override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {\r\n                            if (holder.itemViewType == 0) bindLottieHolder(holder)\r\n                            else bindOtherViewHolder(holder, position)\r\n                        }\r\n\r\n                        private fun bindLottieHolder(holder: RecyclerView.ViewHolder) {\r\n                            if (!animationWasPlayed) {\r\n                                animationView = holder.itemView as LottieAnimationView\r\n                                (holder.itemView as LottieAnimationView).apply {\r\n                                    setAnimation(R.raw.heart)\r\n                                    playAnimation()\r\n                                    animationWasPlayed = true\r\n                                    IdlingRegistry.getInstance().register(LottieIdlingResource(this, name = \"Lottie ${Random.nextFloat()}\"))\r\n                                }\r\n                            } else {\r\n                                IdlingRegistry.getInstance().register(LottieIdlingAnimationResource(animationView, name = \"Lottie finished animation ${Random.nextFloat()}\"))\r\n                            }\r\n                        }\r\n\r\n                        private fun bindOtherViewHolder(holder: RecyclerView.ViewHolder, position: Int) {\r\n                            (holder.itemView as TextView).text = \"Item $position\"\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        val scenario = launchFragmentInContainer<TestFragment>()\r\n        onView(isAssignableFrom(RecyclerView::class.java)).check(matches(isDisplayed()))\r\n        scenario.onFragment { assertTrue(it.animationView!!.isAnimating) }\r\n        scenario.onFragment { it.requireView().scrollBy(0, 10_000) }\r\n        scenario.onFragment { assertFalse(it.animationView!!.isAnimating) }\r\n        scenario.onFragment { it.requireView().scrollBy(0, -10_000) }\r\n        scenario.onFragment { assertTrue(it.animationView!!.isAnimating) }\r\n        onView(withId(R.id.animation_view)).check(matches(isDisplayed()))\r\n        scenario.onFragment { assertFalse(it.animationView!!.isAnimating) }\r\n        scenario.onFragment { it.requireView().scrollBy(0, 10_000) }\r\n        scenario.onFragment { it.requireView().scrollBy(0, -10_000) }\r\n        scenario.onFragment { assertFalse(it.animationView!!.isAnimating) }\r\n    }\r\n```\r\n\r\n- I've introduced new `IdlingResource`, which is waiting until lottie animation is finished:\r\n```\r\nclass LottieIdlingAnimationResource(animationView: LottieAnimationView?, private val name: String = \"Lottie\") : IdlingResource {\r\n\r\n    init {\r\n        animationView?.addAnimatorListener(object : AnimatorListenerAdapter() {\r\n            override fun onAnimationStart(animation: Animator) {\r\n                isIdle = false\r\n            }\r\n\r\n            override fun onAnimationEnd(animation: Animator) {\r\n                isIdle = true\r\n                callback?.onTransitionToIdle()\r\n                animationView.removeAllAnimatorListeners()\r\n                IdlingRegistry.getInstance().unregister(this@LottieIdlingAnimationResource)\r\n            }\r\n        })\r\n    }\r\n\r\n    private var callback: IdlingResource.ResourceCallback? = null\r\n    private var isIdle = animationView?.isAnimating?.not() ?: true\r\n\r\n\r\n    override fun getName() = name\r\n\r\n    override fun isIdleNow() = isIdle\r\n\r\n    override fun registerIdleTransitionCallback(callback: IdlingResource.ResourceCallback?) {\r\n        this.callback = callback\r\n        if (isIdle) callback?.onTransitionToIdle()\r\n    }\r\n}\r\n```\r\n\r\n- Added one line that fixes the issue at `LottieAnimationView.java 286 line` inside `onAttachedToWindow()` callback:\r\n\r\n`wasAnimatingWhenDetached = false;`\r\n\r\nBTW `testPausesWhenScrolledOffScreenAndResumesWhenComesBack()` test could be adjusted to use `animationWasPlayed` boolean(as in mine test) and that will fix it.\r\nProbably my comment is not a small one, because of that I prefer creating a PR. \r\nThanks a lot!\r\n", "bodyText": "@gpeal Sorry for late reply! I was kind of really far away from civilization and stable internet connection. Sure, I have few ideas how that espresso test could be written. Actually I've spent some time analyzing existing Tests inside FragmentVisibilityTests. I think my case is similar to testPausesWhenScrolledOffScreenAndResumesWhenComesBack() test, so I've taken it as an example and base for building mine. While playing around I've found an interesting thing inside that test.\n        val scenario = launchFragmentInContainer<TestFragment>()\n        onView(isAssignableFrom(RecyclerView::class.java)).check(matches(isDisplayed()))\n        scenario.onFragment { assertTrue(it.animationView!!.isAnimating) }\n        scenario.onFragment { it.requireView().scrollBy(0, 10_000) }\n        scenario.onFragment { assertFalse(it.animationView!!.isAnimating) }\n        scenario.onFragment { it.requireView().scrollBy(0, -10_000) }\n        scenario.onFragment { assertTrue(it.animationView!!.isAnimating) }\n\nIn this code snippet we are scrolling back and forth and verifying that animationView restarts animating when it is visible. But that is kinda tricky, as it would be playing animation in any case, because onBindViewHolder()->bindLottieHolder() is called :\nprivate fun bindLottieHolder(holder: RecyclerView.ViewHolder) {\n                          animationView = holder.itemView as LottieAnimationView\n                          (holder.itemView as LottieAnimationView).apply {\n                                repeatCount = LottieDrawable.INFINITE\n                                setAnimation(R.raw.heart)\n                                playAnimation()\n                                IdlingRegistry.getInstance().register(LottieIdlingResource(this, name = \"Lottie ${Random.nextFloat()}\"))\n                            }\n                        }\n\nSo as result playAnimation() is called and in any case animationView!!.isAnimating will return true. Per my mind - this test is testing wrong flow, it should be adjusted. As usually - I could be wrong.\nGoing back to mine case - the best way here is to create a PR, it would be easier to review changes. Anyway I'll explain mine approach and solution here:\n\nI've introduced new test(sorry for naming, I'm not a naming guru):\n\n@Test\nfun testPausesWhenScrolledOffScreenAndResumesWhenComesBackWithoutRepeatingWhenFinished() {\n\n        class TestFragment : Fragment() {\n            var animationView: LottieAnimationView? = null\n            override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {\n                return RecyclerView(requireContext()).apply {\n                    layoutManager = LinearLayoutManager(requireContext(), LinearLayoutManager.VERTICAL, false)\n                    adapter = object : RecyclerView.Adapter<RecyclerView.ViewHolder>() {\n\n                        var animationWasPlayed = false\n\n                        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {\n                            return when (viewType) {\n                                0 -> object : RecyclerView.ViewHolder(\n                                        LottieAnimationView(parent.context)\n                                                .apply { id = R.id.animation_view }\n                                ) {}\n                                else -> object : RecyclerView.ViewHolder(TextView(parent.context)) {}\n                            }\n                        }\n\n                        override fun getItemCount(): Int = 1000\n\n                        override fun getItemViewType(position: Int) = position\n\n                        override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {\n                            if (holder.itemViewType == 0) bindLottieHolder(holder)\n                            else bindOtherViewHolder(holder, position)\n                        }\n\n                        private fun bindLottieHolder(holder: RecyclerView.ViewHolder) {\n                            if (!animationWasPlayed) {\n                                animationView = holder.itemView as LottieAnimationView\n                                (holder.itemView as LottieAnimationView).apply {\n                                    setAnimation(R.raw.heart)\n                                    playAnimation()\n                                    animationWasPlayed = true\n                                    IdlingRegistry.getInstance().register(LottieIdlingResource(this, name = \"Lottie ${Random.nextFloat()}\"))\n                                }\n                            } else {\n                                IdlingRegistry.getInstance().register(LottieIdlingAnimationResource(animationView, name = \"Lottie finished animation ${Random.nextFloat()}\"))\n                            }\n                        }\n\n                        private fun bindOtherViewHolder(holder: RecyclerView.ViewHolder, position: Int) {\n                            (holder.itemView as TextView).text = \"Item $position\"\n                        }\n                    }\n                }\n            }\n        }\n\n        val scenario = launchFragmentInContainer<TestFragment>()\n        onView(isAssignableFrom(RecyclerView::class.java)).check(matches(isDisplayed()))\n        scenario.onFragment { assertTrue(it.animationView!!.isAnimating) }\n        scenario.onFragment { it.requireView().scrollBy(0, 10_000) }\n        scenario.onFragment { assertFalse(it.animationView!!.isAnimating) }\n        scenario.onFragment { it.requireView().scrollBy(0, -10_000) }\n        scenario.onFragment { assertTrue(it.animationView!!.isAnimating) }\n        onView(withId(R.id.animation_view)).check(matches(isDisplayed()))\n        scenario.onFragment { assertFalse(it.animationView!!.isAnimating) }\n        scenario.onFragment { it.requireView().scrollBy(0, 10_000) }\n        scenario.onFragment { it.requireView().scrollBy(0, -10_000) }\n        scenario.onFragment { assertFalse(it.animationView!!.isAnimating) }\n    }\n\n\nI've introduced new IdlingResource, which is waiting until lottie animation is finished:\n\nclass LottieIdlingAnimationResource(animationView: LottieAnimationView?, private val name: String = \"Lottie\") : IdlingResource {\n\n    init {\n        animationView?.addAnimatorListener(object : AnimatorListenerAdapter() {\n            override fun onAnimationStart(animation: Animator) {\n                isIdle = false\n            }\n\n            override fun onAnimationEnd(animation: Animator) {\n                isIdle = true\n                callback?.onTransitionToIdle()\n                animationView.removeAllAnimatorListeners()\n                IdlingRegistry.getInstance().unregister(this@LottieIdlingAnimationResource)\n            }\n        })\n    }\n\n    private var callback: IdlingResource.ResourceCallback? = null\n    private var isIdle = animationView?.isAnimating?.not() ?: true\n\n\n    override fun getName() = name\n\n    override fun isIdleNow() = isIdle\n\n    override fun registerIdleTransitionCallback(callback: IdlingResource.ResourceCallback?) {\n        this.callback = callback\n        if (isIdle) callback?.onTransitionToIdle()\n    }\n}\n\n\nAdded one line that fixes the issue at LottieAnimationView.java 286 line inside onAttachedToWindow() callback:\n\nwasAnimatingWhenDetached = false;\nBTW testPausesWhenScrolledOffScreenAndResumesWhenComesBack() test could be adjusted to use animationWasPlayed boolean(as in mine test) and that will fix it.\nProbably my comment is not a small one, because of that I prefer creating a PR.\nThanks a lot!", "bodyHTML": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/gpeal/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/gpeal\">@gpeal</a> Sorry for late reply! I was kind of really far away from civilization and stable internet connection. Sure, I have few ideas how that espresso test could be written. Actually I've spent some time analyzing existing <code>Tests</code> inside <code>FragmentVisibilityTests</code>. I think my case is similar to <code>testPausesWhenScrolledOffScreenAndResumesWhenComesBack()</code> test, so I've taken it as an example and base for building mine. While playing around I've found an interesting thing inside that test.</p>\n<pre><code>        val scenario = launchFragmentInContainer&lt;TestFragment&gt;()\n        onView(isAssignableFrom(RecyclerView::class.java)).check(matches(isDisplayed()))\n        scenario.onFragment { assertTrue(it.animationView!!.isAnimating) }\n        scenario.onFragment { it.requireView().scrollBy(0, 10_000) }\n        scenario.onFragment { assertFalse(it.animationView!!.isAnimating) }\n        scenario.onFragment { it.requireView().scrollBy(0, -10_000) }\n        scenario.onFragment { assertTrue(it.animationView!!.isAnimating) }\n</code></pre>\n<p>In this code snippet we are scrolling back and forth and verifying that <code>animationView</code> restarts animating when it is visible. But that is kinda tricky, as it would be playing animation in any case, because onBindViewHolder()-&gt;bindLottieHolder() is called :</p>\n<pre><code>private fun bindLottieHolder(holder: RecyclerView.ViewHolder) {\n                          animationView = holder.itemView as LottieAnimationView\n                          (holder.itemView as LottieAnimationView).apply {\n                                repeatCount = LottieDrawable.INFINITE\n                                setAnimation(R.raw.heart)\n                                playAnimation()\n                                IdlingRegistry.getInstance().register(LottieIdlingResource(this, name = \"Lottie ${Random.nextFloat()}\"))\n                            }\n                        }\n</code></pre>\n<p>So as result <code>playAnimation()</code> is called and in any case <code>animationView!!.isAnimating</code> will return <code>true</code>. Per my mind - this test is testing wrong flow, it should be adjusted. As usually - I could be wrong.<br>\nGoing back to mine case - the best way here is to create a PR, it would be easier to review changes. Anyway I'll explain mine approach and solution here:</p>\n<ul>\n<li>I've introduced new test(sorry for naming, I'm not a naming guru):</li>\n</ul>\n<pre><code>@Test\nfun testPausesWhenScrolledOffScreenAndResumesWhenComesBackWithoutRepeatingWhenFinished() {\n\n        class TestFragment : Fragment() {\n            var animationView: LottieAnimationView? = null\n            override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {\n                return RecyclerView(requireContext()).apply {\n                    layoutManager = LinearLayoutManager(requireContext(), LinearLayoutManager.VERTICAL, false)\n                    adapter = object : RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() {\n\n                        var animationWasPlayed = false\n\n                        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {\n                            return when (viewType) {\n                                0 -&gt; object : RecyclerView.ViewHolder(\n                                        LottieAnimationView(parent.context)\n                                                .apply { id = R.id.animation_view }\n                                ) {}\n                                else -&gt; object : RecyclerView.ViewHolder(TextView(parent.context)) {}\n                            }\n                        }\n\n                        override fun getItemCount(): Int = 1000\n\n                        override fun getItemViewType(position: Int) = position\n\n                        override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {\n                            if (holder.itemViewType == 0) bindLottieHolder(holder)\n                            else bindOtherViewHolder(holder, position)\n                        }\n\n                        private fun bindLottieHolder(holder: RecyclerView.ViewHolder) {\n                            if (!animationWasPlayed) {\n                                animationView = holder.itemView as LottieAnimationView\n                                (holder.itemView as LottieAnimationView).apply {\n                                    setAnimation(R.raw.heart)\n                                    playAnimation()\n                                    animationWasPlayed = true\n                                    IdlingRegistry.getInstance().register(LottieIdlingResource(this, name = \"Lottie ${Random.nextFloat()}\"))\n                                }\n                            } else {\n                                IdlingRegistry.getInstance().register(LottieIdlingAnimationResource(animationView, name = \"Lottie finished animation ${Random.nextFloat()}\"))\n                            }\n                        }\n\n                        private fun bindOtherViewHolder(holder: RecyclerView.ViewHolder, position: Int) {\n                            (holder.itemView as TextView).text = \"Item $position\"\n                        }\n                    }\n                }\n            }\n        }\n\n        val scenario = launchFragmentInContainer&lt;TestFragment&gt;()\n        onView(isAssignableFrom(RecyclerView::class.java)).check(matches(isDisplayed()))\n        scenario.onFragment { assertTrue(it.animationView!!.isAnimating) }\n        scenario.onFragment { it.requireView().scrollBy(0, 10_000) }\n        scenario.onFragment { assertFalse(it.animationView!!.isAnimating) }\n        scenario.onFragment { it.requireView().scrollBy(0, -10_000) }\n        scenario.onFragment { assertTrue(it.animationView!!.isAnimating) }\n        onView(withId(R.id.animation_view)).check(matches(isDisplayed()))\n        scenario.onFragment { assertFalse(it.animationView!!.isAnimating) }\n        scenario.onFragment { it.requireView().scrollBy(0, 10_000) }\n        scenario.onFragment { it.requireView().scrollBy(0, -10_000) }\n        scenario.onFragment { assertFalse(it.animationView!!.isAnimating) }\n    }\n</code></pre>\n<ul>\n<li>I've introduced new <code>IdlingResource</code>, which is waiting until lottie animation is finished:</li>\n</ul>\n<pre><code>class LottieIdlingAnimationResource(animationView: LottieAnimationView?, private val name: String = \"Lottie\") : IdlingResource {\n\n    init {\n        animationView?.addAnimatorListener(object : AnimatorListenerAdapter() {\n            override fun onAnimationStart(animation: Animator) {\n                isIdle = false\n            }\n\n            override fun onAnimationEnd(animation: Animator) {\n                isIdle = true\n                callback?.onTransitionToIdle()\n                animationView.removeAllAnimatorListeners()\n                IdlingRegistry.getInstance().unregister(this@LottieIdlingAnimationResource)\n            }\n        })\n    }\n\n    private var callback: IdlingResource.ResourceCallback? = null\n    private var isIdle = animationView?.isAnimating?.not() ?: true\n\n\n    override fun getName() = name\n\n    override fun isIdleNow() = isIdle\n\n    override fun registerIdleTransitionCallback(callback: IdlingResource.ResourceCallback?) {\n        this.callback = callback\n        if (isIdle) callback?.onTransitionToIdle()\n    }\n}\n</code></pre>\n<ul>\n<li>Added one line that fixes the issue at <code>LottieAnimationView.java 286 line</code> inside <code>onAttachedToWindow()</code> callback:</li>\n</ul>\n<p><code>wasAnimatingWhenDetached = false;</code></p>\n<p>BTW <code>testPausesWhenScrolledOffScreenAndResumesWhenComesBack()</code> test could be adjusted to use <code>animationWasPlayed</code> boolean(as in mine test) and that will fix it.<br>\nProbably my comment is not a small one, because of that I prefer creating a PR.<br>\nThanks a lot!</p>", "createdAt": "2019-07-24T19:55:47Z", "publishedAt": "2019-07-24T19:55:47Z", "lastEditedAt": null, "updatedAt": "2019-07-24T19:55:47Z", "reactions": {"edges": [{"node": {"content": "THUMBS_UP", "createdAt": "2019-07-29T13:59:15Z"}}, {"node": {"content": "THUMBS_UP", "createdAt": "2019-08-01T18:17:52Z"}}]}, "bodyParsed": [{"number": 4007, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "@gpeal Sorry for late reply!", "sentSegmented": ["gpeal", "sorry", "for", "late", "reply"], "sentSegmentedWithoutStops": ["gpeal", "sorry", "late", "reply"], "sentSegmentedWithoutStopsStemmed": ["gpeal", "sorri", "late", "repli"]}, {"number": 4008, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "I was kind of really far away from civilization and stable internet connection.", "sentSegmented": ["i", "was", "kind", "of", "really", "far", "away", "from", "civilization", "and", "stable", "internet", "connection"], "sentSegmentedWithoutStops": ["kind", "really", "far", "away", "civilization", "stable", "internet", "connection"], "sentSegmentedWithoutStopsStemmed": ["kind", "realli", "far", "away", "civil", "stabl", "internet", "connect"]}, {"number": 4009, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Sure, I have few ideas how that espresso test could be written.", "sentSegmented": ["sure", "i", "have", "few", "ideas", "how", "that", "espresso", "test", "could", "be", "written"], "sentSegmentedWithoutStops": ["sure", "ideas", "espresso", "test", "could", "written"], "sentSegmentedWithoutStopsStemmed": ["sure", "idea", "espresso", "test", "could", "written"]}, {"number": 4010, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Actually I've spent some time analyzing existing Tests inside FragmentVisibilityTests.", "sentSegmented": ["actually", "i", "'ve", "spent", "some", "time", "analyzing", "existing", "tests", "inside", "fragmentvisibilitytests"], "sentSegmentedWithoutStops": ["actually", "'ve", "spent", "time", "analyzing", "existing", "tests", "inside", "fragmentvisibilitytests"], "sentSegmentedWithoutStopsStemmed": ["actual", "'ve", "spent", "time", "analyz", "exist", "test", "insid", "fragmentvisibilitytest"]}, {"number": 4011, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "I think my case is similar to testPausesWhenScrolledOffScreenAndResumesWhenComesBack() test, so I've taken it as an example and base for building mine.", "sentSegmented": ["i", "think", "my", "case", "is", "similar", "to", "testpauseswhenscrolledoffscreenandresumeswhencomesback", "test", "so", "i", "'ve", "taken", "it", "as", "an", "example", "and", "base", "for", "building", "mine"], "sentSegmentedWithoutStops": ["think", "case", "similar", "testpauseswhenscrolledoffscreenandresumeswhencomesback", "test", "'ve", "taken", "example", "base", "building", "mine"], "sentSegmentedWithoutStopsStemmed": ["think", "case", "similar", "testpauseswhenscrolledoffscreenandresumeswhencomesback", "test", "'ve", "taken", "exampl", "base", "build", "mine"]}, {"number": 4012, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "While playing around I've found an interesting thing inside that test.", "sentSegmented": ["while", "playing", "around", "i", "'ve", "found", "an", "interesting", "thing", "inside", "that", "test"], "sentSegmentedWithoutStops": ["playing", "around", "'ve", "found", "interesting", "thing", "inside", "test"], "sentSegmentedWithoutStopsStemmed": ["play", "around", "'ve", "found", "interest", "thing", "insid", "test"]}, {"number": 4013, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "val scenario = launchFragmentInContainer()", "sentSegmented": ["val", "scenario", "launchfragmentincontainer"], "sentSegmentedWithoutStops": ["scenario", "launchfragmentincontainer"], "sentSegmentedWithoutStopsStemmed": ["scenario", "launchfragmentincontain"]}, {"number": 4014, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        onView(isAssignableFrom(RecyclerView::class.java)).check(matches(isDisplayed()))", "sentSegmented": ["onview", "isassignablefrom", "recyclerview", ":class.java", ".check", "matches", "isdisplayed"], "sentSegmentedWithoutStops": ["onview", "isassignablefrom", "recyclerview", ":class.java", ".check", "matches", "isdisplayed"], "sentSegmentedWithoutStopsStemmed": ["onview", "isassignablefrom", "recyclerview", ":class.java", ".check", "match", "isdisplay"]}, {"number": 4015, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        scenario.onFragment { assertTrue(it.animationView!!.isAnimating) }", "sentSegmented": ["scenario.onfragment", "asserttrue", "it.animationview", ".isanimating"], "sentSegmentedWithoutStops": ["scenario.onfragment", "asserttrue", "it.animationview", ".isanimating"], "sentSegmentedWithoutStopsStemmed": ["scenario.onfrag", "asserttru", "it.animationview", ".isanim"]}, {"number": 4016, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        scenario.onFragment { it.requireView().scrollBy(0, 10_000) }", "sentSegmented": ["scenario.onfragment", "it.requireview", ".scrollby", "0", "10_000"], "sentSegmentedWithoutStops": ["scenario.onfragment", "it.requireview", ".scrollby", "0", "10_000"], "sentSegmentedWithoutStopsStemmed": ["scenario.onfrag", "it.requireview", ".scrollbi", "0", "10_000"]}, {"number": 4017, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        scenario.onFragment { assertFalse(it.animationView!!.isAnimating) }", "sentSegmented": ["scenario.onfragment", "assertfalse", "it.animationview", ".isanimating"], "sentSegmentedWithoutStops": ["scenario.onfragment", "assertfalse", "it.animationview", ".isanimating"], "sentSegmentedWithoutStopsStemmed": ["scenario.onfrag", "assertfals", "it.animationview", ".isanim"]}, {"number": 4018, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        scenario.onFragment { it.requireView().scrollBy(0, -10_000) }", "sentSegmented": ["scenario.onfragment", "it.requireview", ".scrollby", "0", "-10_000"], "sentSegmentedWithoutStops": ["scenario.onfragment", "it.requireview", ".scrollby", "0", "-10_000"], "sentSegmentedWithoutStopsStemmed": ["scenario.onfrag", "it.requireview", ".scrollbi", "0", "-10_000"]}, {"number": 4019, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        scenario.onFragment { assertTrue(it.animationView!!.isAnimating) }", "sentSegmented": ["scenario.onfragment", "asserttrue", "it.animationview", ".isanimating"], "sentSegmentedWithoutStops": ["scenario.onfragment", "asserttrue", "it.animationview", ".isanimating"], "sentSegmentedWithoutStopsStemmed": ["scenario.onfrag", "asserttru", "it.animationview", ".isanim"]}, {"number": 4020, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "In this code snippet we are scrolling back and forth and verifying that animationView restarts animating when it is visible.", "sentSegmented": ["in", "this", "code", "snippet", "we", "are", "scrolling", "back", "and", "forth", "and", "verifying", "that", "animationview", "restarts", "animating", "when", "it", "is", "visible"], "sentSegmentedWithoutStops": ["code", "snippet", "scrolling", "back", "forth", "verifying", "animationview", "restarts", "animating", "visible"], "sentSegmentedWithoutStopsStemmed": ["code", "snippet", "scroll", "back", "forth", "verifi", "animationview", "restart", "anim", "visibl"]}, {"number": 4021, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "But that is kinda tricky, as it would be playing animation in any case, because onBindViewHolder()->bindLottieHolder() is called :", "sentSegmented": ["but", "that", "is", "kinda", "tricky", "as", "it", "would", "be", "playing", "animation", "in", "any", "case", "because", "onbindviewholder", "bindlottieholder", "is", "called"], "sentSegmentedWithoutStops": ["kinda", "tricky", "would", "playing", "animation", "case", "onbindviewholder", "bindlottieholder", "called"], "sentSegmentedWithoutStopsStemmed": ["kinda", "tricki", "would", "play", "anim", "case", "onbindviewhold", "bindlottiehold", "call"]}, {"number": 4022, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "private fun bindLottieHolder(holder: RecyclerView.ViewHolder) {", "sentSegmented": ["private", "fun", "bindlottieholder", "holder", "recyclerview.viewholder"], "sentSegmentedWithoutStops": ["bindlottieholder", "holder", "recyclerview.viewholder"], "sentSegmentedWithoutStopsStemmed": ["bindlottiehold", "holder", "recyclerview.viewhold"]}, {"number": 4023, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                          animationView = holder.itemView as LottieAnimationView", "sentSegmented": ["animationview", "holder.itemview", "as", "lottieanimationview"], "sentSegmentedWithoutStops": ["animationview", "holder.itemview", "lottieanimationview"], "sentSegmentedWithoutStopsStemmed": ["animationview", "holder.itemview", "lottieanimationview"]}, {"number": 4024, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                          (holder.itemView as LottieAnimationView).apply {", "sentSegmented": ["holder.itemview", "as", "lottieanimationview", ".apply"], "sentSegmentedWithoutStops": ["holder.itemview", "lottieanimationview", ".apply"], "sentSegmentedWithoutStopsStemmed": ["holder.itemview", "lottieanimationview", ".appli"]}, {"number": 4025, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                                repeatCount = LottieDrawable.INFINITE", "sentSegmented": ["repeatcount", "lottiedrawable.infinite"], "sentSegmentedWithoutStops": ["repeatcount", "lottiedrawable.infinite"], "sentSegmentedWithoutStopsStemmed": ["repeatcount", "lottiedrawable.infinit"]}, {"number": 4026, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                                setAnimation(R.raw.heart)", "sentSegmented": ["setanimation", "r.raw.heart"], "sentSegmentedWithoutStops": ["setanimation", "r.raw.heart"], "sentSegmentedWithoutStopsStemmed": ["setanim", "r.raw.heart"]}, {"number": 4027, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                                playAnimation()", "sentSegmented": ["playanimation"], "sentSegmentedWithoutStops": ["playanimation"], "sentSegmentedWithoutStopsStemmed": ["playanim"]}, {"number": 4028, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                                IdlingRegistry.getInstance().register(LottieIdlingResource(this, name = \"Lottie ${Random.nextFloat()}\"))", "sentSegmented": ["idlingregistry.getinstance", ".register", "lottieidlingresource", "this", "name", "lottie", "random.nextfloat"], "sentSegmentedWithoutStops": ["idlingregistry.getinstance", ".register", "lottieidlingresource", "name", "lottie", "random.nextfloat"], "sentSegmentedWithoutStopsStemmed": ["idlingregistry.getinst", ".regist", "lottieidlingresourc", "name", "lotti", "random.nextfloat"]}, {"number": 4029, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                            }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4030, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                        }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4031, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "So as result playAnimation() is called and in any case animationView!", "sentSegmented": ["so", "as", "result", "playanimation", "is", "called", "and", "in", "any", "case", "animationview"], "sentSegmentedWithoutStops": ["result", "playanimation", "called", "case", "animationview"], "sentSegmentedWithoutStopsStemmed": ["result", "playanim", "call", "case", "animationview"]}, {"number": 4032, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "!.isAnimating will return true.", "sentSegmented": [".isanimating", "will", "return", "true"], "sentSegmentedWithoutStops": [".isanimating", "return", "true"], "sentSegmentedWithoutStopsStemmed": [".isanim", "return", "true"]}, {"number": 4033, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Per my mind - this test is testing wrong flow, it should be adjusted.", "sentSegmented": ["per", "my", "mind", "this", "test", "is", "testing", "wrong", "flow", "it", "should", "be", "adjusted"], "sentSegmentedWithoutStops": ["per", "mind", "test", "testing", "wrong", "flow", "adjusted"], "sentSegmentedWithoutStopsStemmed": ["per", "mind", "test", "test", "wrong", "flow", "adjust"]}, {"number": 4034, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "As usually - I could be wrong.", "sentSegmented": ["as", "usually", "i", "could", "be", "wrong"], "sentSegmentedWithoutStops": ["usually", "could", "wrong"], "sentSegmentedWithoutStopsStemmed": ["usual", "could", "wrong"]}, {"number": 4035, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Going back to mine case - the best way here is to create a PR, it would be easier to review changes.", "sentSegmented": ["going", "back", "to", "mine", "case", "the", "best", "way", "here", "is", "to", "create", "a", "pr", "it", "would", "be", "easier", "to", "review", "changes"], "sentSegmentedWithoutStops": ["going", "back", "mine", "case", "best", "way", "create", "pr", "would", "easier", "review", "changes"], "sentSegmentedWithoutStopsStemmed": ["go", "back", "mine", "case", "best", "way", "creat", "pr", "would", "easier", "review", "chang"]}, {"number": 4036, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Anyway I'll explain mine approach and solution here:", "sentSegmented": ["anyway", "i", "'ll", "explain", "mine", "approach", "and", "solution", "here"], "sentSegmentedWithoutStops": ["anyway", "'ll", "explain", "mine", "approach", "solution"], "sentSegmentedWithoutStopsStemmed": ["anyway", "'ll", "explain", "mine", "approach", "solut"]}, {"number": 4037, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "I've introduced new test(sorry for naming, I'm not a naming guru):", "sentSegmented": ["i", "'ve", "introduced", "new", "test", "sorry", "for", "naming", "i", "'m", "not", "a", "naming", "guru"], "sentSegmentedWithoutStops": ["'ve", "introduced", "new", "test", "sorry", "naming", "'m", "naming", "guru"], "sentSegmentedWithoutStopsStemmed": ["'ve", "introduc", "new", "test", "sorri", "name", "'m", "name", "guru"]}, {"number": 4038, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "@Test", "sentSegmented": ["test"], "sentSegmentedWithoutStops": ["test"], "sentSegmentedWithoutStopsStemmed": ["test"]}, {"number": 4039, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "fun testPausesWhenScrolledOffScreenAndResumesWhenComesBackWithoutRepeatingWhenFinished() {", "sentSegmented": ["fun", "testpauseswhenscrolledoffscreenandresumeswhencomesbackwithoutrepeatingwhenfinished"], "sentSegmentedWithoutStops": ["testpauseswhenscrolledoffscreenandresumeswhencomesbackwithoutrepeatingwhenfinished"], "sentSegmentedWithoutStopsStemmed": ["testpauseswhenscrolledoffscreenandresumeswhencomesbackwithoutrepeatingwhenfinish"]}, {"number": 4040, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        class TestFragment : Fragment() {", "sentSegmented": ["class", "testfragment", "fragment"], "sentSegmentedWithoutStops": ["testfragment", "fragment"], "sentSegmentedWithoutStopsStemmed": ["testfrag", "fragment"]}, {"number": 4041, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "            var animationView: LottieAnimationView? = null", "sentSegmented": ["var", "animationview", "lottieanimationview", "null"], "sentSegmentedWithoutStops": ["animationview", "lottieanimationview"], "sentSegmentedWithoutStopsStemmed": ["animationview", "lottieanimationview"]}, {"number": 4042, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "            override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {", "sentSegmented": ["override", "fun", "oncreateview", "inflater", "layoutinflater", "container", "viewgroup", "savedinstancestate", "bundle", "view"], "sentSegmentedWithoutStops": ["oncreateview", "inflater", "layoutinflater", "container", "viewgroup", "savedinstancestate", "bundle", "view"], "sentSegmentedWithoutStopsStemmed": ["oncreateview", "inflat", "layoutinflat", "contain", "viewgroup", "savedinstancest", "bundl", "view"]}, {"number": 4043, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                return RecyclerView(requireContext()).apply {", "sentSegmented": ["return", "recyclerview", "requirecontext", ".apply"], "sentSegmentedWithoutStops": ["recyclerview", "requirecontext", ".apply"], "sentSegmentedWithoutStopsStemmed": ["recyclerview", "requirecontext", ".appli"]}, {"number": 4044, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                    layoutManager = LinearLayoutManager(requireContext(), LinearLayoutManager.VERTICAL, false)", "sentSegmented": ["layoutmanager", "linearlayoutmanager", "requirecontext", "linearlayoutmanager.vertical", "false"], "sentSegmentedWithoutStops": ["layoutmanager", "linearlayoutmanager", "requirecontext", "linearlayoutmanager.vertical"], "sentSegmentedWithoutStopsStemmed": ["layoutmanag", "linearlayoutmanag", "requirecontext", "linearlayoutmanager.vert"]}, {"number": 4045, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                    adapter = object : RecyclerView.Adapter() {", "sentSegmented": ["adapter", "object", "recyclerview.adapter"], "sentSegmentedWithoutStops": ["adapter", "recyclerview.adapter"], "sentSegmentedWithoutStopsStemmed": ["adapt", "recyclerview.adapt"]}, {"number": 4046, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                        var animationWasPlayed = false", "sentSegmented": ["var", "animationwasplayed", "false"], "sentSegmentedWithoutStops": ["animationwasplayed"], "sentSegmentedWithoutStopsStemmed": ["animationwasplay"]}, {"number": 4047, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {", "sentSegmented": ["override", "fun", "oncreateviewholder", "parent", "viewgroup", "viewtype", "int", "recyclerview.viewholder"], "sentSegmentedWithoutStops": ["oncreateviewholder", "parent", "viewgroup", "viewtype", "recyclerview.viewholder"], "sentSegmentedWithoutStopsStemmed": ["oncreateviewhold", "parent", "viewgroup", "viewtyp", "recyclerview.viewhold"]}, {"number": 4048, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                            return when (viewType) {", "sentSegmented": ["return", "when", "viewtype"], "sentSegmentedWithoutStops": ["viewtype"], "sentSegmentedWithoutStopsStemmed": ["viewtyp"]}, {"number": 4049, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                                0 -> object : RecyclerView.ViewHolder(", "sentSegmented": ["0", "object", "recyclerview.viewholder"], "sentSegmentedWithoutStops": ["0", "recyclerview.viewholder"], "sentSegmentedWithoutStopsStemmed": ["0", "recyclerview.viewhold"]}, {"number": 4050, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                                        LottieAnimationView(parent.context)", "sentSegmented": ["lottieanimationview", "parent.context"], "sentSegmentedWithoutStops": ["lottieanimationview", "parent.context"], "sentSegmentedWithoutStopsStemmed": ["lottieanimationview", "parent.context"]}, {"number": 4051, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                                                .apply { id = R.id.animation_view }", "sentSegmented": [".apply", "id", "r.id.animation_view"], "sentSegmentedWithoutStops": [".apply", "id", "r.id.animation_view"], "sentSegmentedWithoutStopsStemmed": [".appli", "id", "r.id.animation_view"]}, {"number": 4052, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                                ) {}", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4053, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                                else -> object : RecyclerView.ViewHolder(TextView(parent.context)) {}", "sentSegmented": ["else", "object", "recyclerview.viewholder", "textview", "parent.context"], "sentSegmentedWithoutStops": ["recyclerview.viewholder", "textview", "parent.context"], "sentSegmentedWithoutStopsStemmed": ["recyclerview.viewhold", "textview", "parent.context"]}, {"number": 4054, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                            }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4055, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                        }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4056, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                        override fun getItemCount(): Int = 1000", "sentSegmented": ["override", "fun", "getitemcount", "int", "1000"], "sentSegmentedWithoutStops": ["getitemcount", "1000"], "sentSegmentedWithoutStopsStemmed": ["getitemcount", "1000"]}, {"number": 4057, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                        override fun getItemViewType(position: Int) = position", "sentSegmented": ["override", "fun", "getitemviewtype", "position", "int", "position"], "sentSegmentedWithoutStops": ["getitemviewtype", "position", "position"], "sentSegmentedWithoutStopsStemmed": ["getitemviewtyp", "posit", "posit"]}, {"number": 4058, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                        override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {", "sentSegmented": ["override", "fun", "onbindviewholder", "holder", "recyclerview.viewholder", "position", "int"], "sentSegmentedWithoutStops": ["onbindviewholder", "holder", "recyclerview.viewholder", "position"], "sentSegmentedWithoutStopsStemmed": ["onbindviewhold", "holder", "recyclerview.viewhold", "posit"]}, {"number": 4059, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                            if (holder.itemViewType == 0) bindLottieHolder(holder)", "sentSegmented": ["if", "holder.itemviewtype", "0", "bindlottieholder", "holder"], "sentSegmentedWithoutStops": ["holder.itemviewtype", "0", "bindlottieholder", "holder"], "sentSegmentedWithoutStopsStemmed": ["holder.itemviewtyp", "0", "bindlottiehold", "holder"]}, {"number": 4060, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                            else bindOtherViewHolder(holder, position)", "sentSegmented": ["else", "bindotherviewholder", "holder", "position"], "sentSegmentedWithoutStops": ["bindotherviewholder", "holder", "position"], "sentSegmentedWithoutStopsStemmed": ["bindotherviewhold", "holder", "posit"]}, {"number": 4061, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                        }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4062, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                        private fun bindLottieHolder(holder: RecyclerView.ViewHolder) {", "sentSegmented": ["private", "fun", "bindlottieholder", "holder", "recyclerview.viewholder"], "sentSegmentedWithoutStops": ["bindlottieholder", "holder", "recyclerview.viewholder"], "sentSegmentedWithoutStopsStemmed": ["bindlottiehold", "holder", "recyclerview.viewhold"]}, {"number": 4063, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                            if (!animationWasPlayed) {", "sentSegmented": ["if", "animationwasplayed"], "sentSegmentedWithoutStops": ["animationwasplayed"], "sentSegmentedWithoutStopsStemmed": ["animationwasplay"]}, {"number": 4064, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                                animationView = holder.itemView as LottieAnimationView", "sentSegmented": ["animationview", "holder.itemview", "as", "lottieanimationview"], "sentSegmentedWithoutStops": ["animationview", "holder.itemview", "lottieanimationview"], "sentSegmentedWithoutStopsStemmed": ["animationview", "holder.itemview", "lottieanimationview"]}, {"number": 4065, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                                (holder.itemView as LottieAnimationView).apply {", "sentSegmented": ["holder.itemview", "as", "lottieanimationview", ".apply"], "sentSegmentedWithoutStops": ["holder.itemview", "lottieanimationview", ".apply"], "sentSegmentedWithoutStopsStemmed": ["holder.itemview", "lottieanimationview", ".appli"]}, {"number": 4066, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                                    setAnimation(R.raw.heart)", "sentSegmented": ["setanimation", "r.raw.heart"], "sentSegmentedWithoutStops": ["setanimation", "r.raw.heart"], "sentSegmentedWithoutStopsStemmed": ["setanim", "r.raw.heart"]}, {"number": 4067, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                                    playAnimation()", "sentSegmented": ["playanimation"], "sentSegmentedWithoutStops": ["playanimation"], "sentSegmentedWithoutStopsStemmed": ["playanim"]}, {"number": 4068, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                                    animationWasPlayed = true", "sentSegmented": ["animationwasplayed", "true"], "sentSegmentedWithoutStops": ["animationwasplayed"], "sentSegmentedWithoutStopsStemmed": ["animationwasplay"]}, {"number": 4069, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                                    IdlingRegistry.getInstance().register(LottieIdlingResource(this, name = \"Lottie ${Random.nextFloat()}\"))", "sentSegmented": ["idlingregistry.getinstance", ".register", "lottieidlingresource", "this", "name", "lottie", "random.nextfloat"], "sentSegmentedWithoutStops": ["idlingregistry.getinstance", ".register", "lottieidlingresource", "name", "lottie", "random.nextfloat"], "sentSegmentedWithoutStopsStemmed": ["idlingregistry.getinst", ".regist", "lottieidlingresourc", "name", "lotti", "random.nextfloat"]}, {"number": 4070, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                                }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4071, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                            } else {", "sentSegmented": ["else"], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4072, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                                IdlingRegistry.getInstance().register(LottieIdlingAnimationResource(animationView, name = \"Lottie finished animation ${Random.nextFloat()}\"))", "sentSegmented": ["idlingregistry.getinstance", ".register", "lottieidlinganimationresource", "animationview", "name", "lottie", "finished", "animation", "random.nextfloat"], "sentSegmentedWithoutStops": ["idlingregistry.getinstance", ".register", "lottieidlinganimationresource", "animationview", "name", "lottie", "finished", "animation", "random.nextfloat"], "sentSegmentedWithoutStopsStemmed": ["idlingregistry.getinst", ".regist", "lottieidlinganimationresourc", "animationview", "name", "lotti", "finish", "anim", "random.nextfloat"]}, {"number": 4073, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                            }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4074, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                        }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4075, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                        private fun bindOtherViewHolder(holder: RecyclerView.ViewHolder, position: Int) {", "sentSegmented": ["private", "fun", "bindotherviewholder", "holder", "recyclerview.viewholder", "position", "int"], "sentSegmentedWithoutStops": ["bindotherviewholder", "holder", "recyclerview.viewholder", "position"], "sentSegmentedWithoutStopsStemmed": ["bindotherviewhold", "holder", "recyclerview.viewhold", "posit"]}, {"number": 4076, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                            (holder.itemView as TextView).text = \"Item $position\"", "sentSegmented": ["holder.itemview", "as", "textview", ".text", "item", "position"], "sentSegmentedWithoutStops": ["holder.itemview", "textview", ".text", "item", "position"], "sentSegmentedWithoutStopsStemmed": ["holder.itemview", "textview", ".text", "item", "posit"]}, {"number": 4077, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                        }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4078, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                    }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4079, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4080, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "            }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4081, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4082, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        val scenario = launchFragmentInContainer()", "sentSegmented": ["val", "scenario", "launchfragmentincontainer"], "sentSegmentedWithoutStops": ["scenario", "launchfragmentincontainer"], "sentSegmentedWithoutStopsStemmed": ["scenario", "launchfragmentincontain"]}, {"number": 4083, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        onView(isAssignableFrom(RecyclerView::class.java)).check(matches(isDisplayed()))", "sentSegmented": ["onview", "isassignablefrom", "recyclerview", ":class.java", ".check", "matches", "isdisplayed"], "sentSegmentedWithoutStops": ["onview", "isassignablefrom", "recyclerview", ":class.java", ".check", "matches", "isdisplayed"], "sentSegmentedWithoutStopsStemmed": ["onview", "isassignablefrom", "recyclerview", ":class.java", ".check", "match", "isdisplay"]}, {"number": 4084, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        scenario.onFragment { assertTrue(it.animationView!!.isAnimating) }", "sentSegmented": ["scenario.onfragment", "asserttrue", "it.animationview", ".isanimating"], "sentSegmentedWithoutStops": ["scenario.onfragment", "asserttrue", "it.animationview", ".isanimating"], "sentSegmentedWithoutStopsStemmed": ["scenario.onfrag", "asserttru", "it.animationview", ".isanim"]}, {"number": 4085, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        scenario.onFragment { it.requireView().scrollBy(0, 10_000) }", "sentSegmented": ["scenario.onfragment", "it.requireview", ".scrollby", "0", "10_000"], "sentSegmentedWithoutStops": ["scenario.onfragment", "it.requireview", ".scrollby", "0", "10_000"], "sentSegmentedWithoutStopsStemmed": ["scenario.onfrag", "it.requireview", ".scrollbi", "0", "10_000"]}, {"number": 4086, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        scenario.onFragment { assertFalse(it.animationView!!.isAnimating) }", "sentSegmented": ["scenario.onfragment", "assertfalse", "it.animationview", ".isanimating"], "sentSegmentedWithoutStops": ["scenario.onfragment", "assertfalse", "it.animationview", ".isanimating"], "sentSegmentedWithoutStopsStemmed": ["scenario.onfrag", "assertfals", "it.animationview", ".isanim"]}, {"number": 4087, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        scenario.onFragment { it.requireView().scrollBy(0, -10_000) }", "sentSegmented": ["scenario.onfragment", "it.requireview", ".scrollby", "0", "-10_000"], "sentSegmentedWithoutStops": ["scenario.onfragment", "it.requireview", ".scrollby", "0", "-10_000"], "sentSegmentedWithoutStopsStemmed": ["scenario.onfrag", "it.requireview", ".scrollbi", "0", "-10_000"]}, {"number": 4088, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        scenario.onFragment { assertTrue(it.animationView!!.isAnimating) }", "sentSegmented": ["scenario.onfragment", "asserttrue", "it.animationview", ".isanimating"], "sentSegmentedWithoutStops": ["scenario.onfragment", "asserttrue", "it.animationview", ".isanimating"], "sentSegmentedWithoutStopsStemmed": ["scenario.onfrag", "asserttru", "it.animationview", ".isanim"]}, {"number": 4089, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        onView(withId(R.id.animation_view)).check(matches(isDisplayed()))", "sentSegmented": ["onview", "withid", "r.id.animation_view", ".check", "matches", "isdisplayed"], "sentSegmentedWithoutStops": ["onview", "withid", "r.id.animation_view", ".check", "matches", "isdisplayed"], "sentSegmentedWithoutStopsStemmed": ["onview", "withid", "r.id.animation_view", ".check", "match", "isdisplay"]}, {"number": 4090, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        scenario.onFragment { assertFalse(it.animationView!!.isAnimating) }", "sentSegmented": ["scenario.onfragment", "assertfalse", "it.animationview", ".isanimating"], "sentSegmentedWithoutStops": ["scenario.onfragment", "assertfalse", "it.animationview", ".isanimating"], "sentSegmentedWithoutStopsStemmed": ["scenario.onfrag", "assertfals", "it.animationview", ".isanim"]}, {"number": 4091, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        scenario.onFragment { it.requireView().scrollBy(0, 10_000) }", "sentSegmented": ["scenario.onfragment", "it.requireview", ".scrollby", "0", "10_000"], "sentSegmentedWithoutStops": ["scenario.onfragment", "it.requireview", ".scrollby", "0", "10_000"], "sentSegmentedWithoutStopsStemmed": ["scenario.onfrag", "it.requireview", ".scrollbi", "0", "10_000"]}, {"number": 4092, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        scenario.onFragment { it.requireView().scrollBy(0, -10_000) }", "sentSegmented": ["scenario.onfragment", "it.requireview", ".scrollby", "0", "-10_000"], "sentSegmentedWithoutStops": ["scenario.onfragment", "it.requireview", ".scrollby", "0", "-10_000"], "sentSegmentedWithoutStopsStemmed": ["scenario.onfrag", "it.requireview", ".scrollbi", "0", "-10_000"]}, {"number": 4093, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        scenario.onFragment { assertFalse(it.animationView!!.isAnimating) }", "sentSegmented": ["scenario.onfragment", "assertfalse", "it.animationview", ".isanimating"], "sentSegmentedWithoutStops": ["scenario.onfragment", "assertfalse", "it.animationview", ".isanimating"], "sentSegmentedWithoutStopsStemmed": ["scenario.onfrag", "assertfals", "it.animationview", ".isanim"]}, {"number": 4094, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4095, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "I've introduced new IdlingResource, which is waiting until lottie animation is finished:", "sentSegmented": ["i", "'ve", "introduced", "new", "idlingresource", "which", "is", "waiting", "until", "lottie", "animation", "is", "finished"], "sentSegmentedWithoutStops": ["'ve", "introduced", "new", "idlingresource", "waiting", "lottie", "animation", "finished"], "sentSegmentedWithoutStopsStemmed": ["'ve", "introduc", "new", "idlingresourc", "wait", "lotti", "anim", "finish"]}, {"number": 4096, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "class LottieIdlingAnimationResource(animationView: LottieAnimationView?, private val name: String = \"Lottie\") : IdlingResource {", "sentSegmented": ["class", "lottieidlinganimationresource", "animationview", "lottieanimationview", "private", "val", "name", "string", "lottie", "idlingresource"], "sentSegmentedWithoutStops": ["lottieidlinganimationresource", "animationview", "lottieanimationview", "name", "string", "lottie", "idlingresource"], "sentSegmentedWithoutStopsStemmed": ["lottieidlinganimationresourc", "animationview", "lottieanimationview", "name", "string", "lotti", "idlingresourc"]}, {"number": 4097, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    init {", "sentSegmented": ["init"], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4098, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        animationView?.addAnimatorListener(object : AnimatorListenerAdapter() {", "sentSegmented": ["animationview", ".addanimatorlistener", "object", "animatorlisteneradapter"], "sentSegmentedWithoutStops": ["animationview", ".addanimatorlistener", "animatorlisteneradapter"], "sentSegmentedWithoutStopsStemmed": ["animationview", ".addanimatorlisten", "animatorlisteneradapt"]}, {"number": 4099, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "            override fun onAnimationStart(animation: Animator) {", "sentSegmented": ["override", "fun", "onanimationstart", "animation", "animator"], "sentSegmentedWithoutStops": ["onanimationstart", "animation", "animator"], "sentSegmentedWithoutStopsStemmed": ["onanimationstart", "anim", "anim"]}, {"number": 4100, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                isIdle = false", "sentSegmented": ["isidle", "false"], "sentSegmentedWithoutStops": ["isidle"], "sentSegmentedWithoutStopsStemmed": ["isidl"]}, {"number": 4101, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "            }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4102, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "            override fun onAnimationEnd(animation: Animator) {", "sentSegmented": ["override", "fun", "onanimationend", "animation", "animator"], "sentSegmentedWithoutStops": ["onanimationend", "animation", "animator"], "sentSegmentedWithoutStopsStemmed": ["onanimationend", "anim", "anim"]}, {"number": 4103, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                isIdle = true", "sentSegmented": ["isidle", "true"], "sentSegmentedWithoutStops": ["isidle"], "sentSegmentedWithoutStopsStemmed": ["isidl"]}, {"number": 4104, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                callback?.onTransitionToIdle()", "sentSegmented": ["callback", ".ontransitiontoidle"], "sentSegmentedWithoutStops": ["callback", ".ontransitiontoidle"], "sentSegmentedWithoutStopsStemmed": ["callback", ".ontransitiontoidl"]}, {"number": 4105, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                animationView.removeAllAnimatorListeners()", "sentSegmented": ["animationview.removeallanimatorlisteners"], "sentSegmentedWithoutStops": ["animationview.removeallanimatorlisteners"], "sentSegmentedWithoutStopsStemmed": ["animationview.removeallanimatorlisten"]}, {"number": 4106, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "                IdlingRegistry.getInstance().unregister(this@LottieIdlingAnimationResource)", "sentSegmented": ["idlingregistry.getinstance", ".unregister", "this", "lottieidlinganimationresource"], "sentSegmentedWithoutStops": ["idlingregistry.getinstance", ".unregister", "lottieidlinganimationresource"], "sentSegmentedWithoutStopsStemmed": ["idlingregistry.getinst", ".unregist", "lottieidlinganimationresourc"]}, {"number": 4107, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "            }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4108, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        })", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4109, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4110, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    private var callback: IdlingResource.ResourceCallback? = null", "sentSegmented": ["private", "var", "callback", "idlingresource.resourcecallback", "null"], "sentSegmentedWithoutStops": ["callback", "idlingresource.resourcecallback"], "sentSegmentedWithoutStopsStemmed": ["callback", "idlingresource.resourcecallback"]}, {"number": 4111, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    private var isIdle = animationView?.isAnimating?.not() ?: true", "sentSegmented": ["private", "var", "isidle", "animationview", ".isanimating", ".not", "true"], "sentSegmentedWithoutStops": ["isidle", "animationview", ".isanimating", ".not"], "sentSegmentedWithoutStopsStemmed": ["isidl", "animationview", ".isanim", ".not"]}, {"number": 4112, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    override fun getName() = name", "sentSegmented": ["override", "fun", "getname", "name"], "sentSegmentedWithoutStops": ["getname", "name"], "sentSegmentedWithoutStopsStemmed": ["getnam", "name"]}, {"number": 4113, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    override fun isIdleNow() = isIdle", "sentSegmented": ["override", "fun", "isidlenow", "isidle"], "sentSegmentedWithoutStops": ["isidlenow", "isidle"], "sentSegmentedWithoutStopsStemmed": ["isidlenow", "isidl"]}, {"number": 4114, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    override fun registerIdleTransitionCallback(callback: IdlingResource.ResourceCallback?) {", "sentSegmented": ["override", "fun", "registeridletransitioncallback", "callback", "idlingresource.resourcecallback"], "sentSegmentedWithoutStops": ["registeridletransitioncallback", "callback", "idlingresource.resourcecallback"], "sentSegmentedWithoutStopsStemmed": ["registeridletransitioncallback", "callback", "idlingresource.resourcecallback"]}, {"number": 4115, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        this.callback = callback", "sentSegmented": ["this.callback", "callback"], "sentSegmentedWithoutStops": ["this.callback", "callback"], "sentSegmentedWithoutStopsStemmed": ["this.callback", "callback"]}, {"number": 4116, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        if (isIdle) callback?.onTransitionToIdle()", "sentSegmented": ["if", "isidle", "callback", ".ontransitiontoidle"], "sentSegmentedWithoutStops": ["isidle", "callback", ".ontransitiontoidle"], "sentSegmentedWithoutStopsStemmed": ["isidl", "callback", ".ontransitiontoidl"]}, {"number": 4117, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4118, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "}", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4119, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Added one line that fixes the issue at LottieAnimationView.java 286 line inside onAttachedToWindow() callback:", "sentSegmented": ["added", "one", "line", "that", "fixes", "the", "issue", "at", "lottieanimationview.java", "286", "line", "inside", "onattachedtowindow", "callback"], "sentSegmentedWithoutStops": ["added", "one", "line", "fixes", "issue", "lottieanimationview.java", "286", "line", "inside", "onattachedtowindow", "callback"], "sentSegmentedWithoutStopsStemmed": ["ad", "one", "line", "fix", "issu", "lottieanimationview.java", "286", "line", "insid", "onattachedtowindow", "callback"]}, {"number": 4120, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "wasAnimatingWhenDetached = false;", "sentSegmented": ["wasanimatingwhendetached", "false"], "sentSegmentedWithoutStops": ["wasanimatingwhendetached", "false"], "sentSegmentedWithoutStopsStemmed": ["wasanimatingwhendetach", "fals"]}, {"number": 4121, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "BTW testPausesWhenScrolledOffScreenAndResumesWhenComesBack() test could be adjusted to use animationWasPlayed boolean(as in mine test) and that will fix it.", "sentSegmented": ["btw", "testpauseswhenscrolledoffscreenandresumeswhencomesback", "test", "could", "be", "adjusted", "to", "use", "animationwasplayed", "boolean", "as", "in", "mine", "test", "and", "that", "will", "fix", "it"], "sentSegmentedWithoutStops": ["btw", "testpauseswhenscrolledoffscreenandresumeswhencomesback", "test", "could", "adjusted", "use", "animationwasplayed", "boolean", "mine", "test", "fix"], "sentSegmentedWithoutStopsStemmed": ["btw", "testpauseswhenscrolledoffscreenandresumeswhencomesback", "test", "could", "adjust", "use", "animationwasplay", "boolean", "mine", "test", "fix"]}, {"number": 4122, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Probably my comment is not a small one, because of that I prefer creating a PR.", "sentSegmented": ["probably", "my", "comment", "is", "not", "a", "small", "one", "because", "of", "that", "i", "prefer", "creating", "a", "pr"], "sentSegmentedWithoutStops": ["probably", "comment", "small", "one", "prefer", "creating", "pr"], "sentSegmentedWithoutStopsStemmed": ["probabl", "comment", "small", "one", "prefer", "creat", "pr"]}, {"number": 4123, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Thanks a lot!", "sentSegmented": ["thanks", "a", "lot"], "sentSegmentedWithoutStops": ["thanks", "lot"], "sentSegmentedWithoutStopsStemmed": ["thank", "lot"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDUxNjgyMzYwMw==", "author": {"login": "YuriiTsap"}, "body": "@gpeal Any updates on this thread? Is it possible to create a PR?", "bodyText": "@gpeal Any updates on this thread? Is it possible to create a PR?", "bodyHTML": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/gpeal/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/gpeal\">@gpeal</a> Any updates on this thread? Is it possible to create a PR?</p>", "createdAt": "2019-07-31T12:17:21Z", "publishedAt": "2019-07-31T12:17:21Z", "lastEditedAt": null, "updatedAt": "2019-07-31T12:17:21Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 4124, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "@gpeal Any updates on this thread?", "sentSegmented": ["gpeal", "any", "updates", "on", "this", "thread"], "sentSegmentedWithoutStops": ["gpeal", "updates", "thread"], "sentSegmentedWithoutStopsStemmed": ["gpeal", "updat", "thread"]}, {"number": 4125, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Is it possible to create a PR?", "sentSegmented": ["is", "it", "possible", "to", "create", "a", "pr"], "sentSegmentedWithoutStops": ["possible", "create", "pr"], "sentSegmentedWithoutStopsStemmed": ["possibl", "creat", "pr"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDUxNzA2NDA4NQ==", "author": {"login": "gpeal"}, "body": "@YuriiTsap Feel free to make a PR :) ", "bodyText": "@YuriiTsap Feel free to make a PR :)", "bodyHTML": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/YuriiTsap/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/YuriiTsap\">@YuriiTsap</a> Feel free to make a PR :)</p>", "createdAt": "2019-07-31T23:51:09Z", "publishedAt": "2019-07-31T23:51:09Z", "lastEditedAt": null, "updatedAt": "2019-07-31T23:51:09Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 4126, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "@YuriiTsap Feel free to make a PR :)", "sentSegmented": ["yuriitsap", "feel", "free", "to", "make", "a", "pr"], "sentSegmentedWithoutStops": ["yuriitsap", "feel", "free", "make", "pr"], "sentSegmentedWithoutStopsStemmed": ["yuriitsap", "feel", "free", "make", "pr"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDU0NDc0NzE5OA==", "author": {"login": "sahibjaspal"}, "body": "I'm still seeing this in `3.1.0`. Using `post { lottieView.playAnimation() }` works for now (https://github.com/airbnb/lottie-android/issues/1284#issuecomment-507229013).", "bodyText": "I'm still seeing this in 3.1.0. Using post { lottieView.playAnimation() } works for now (#1284 (comment)).", "bodyHTML": "<p>I'm still seeing this in <code>3.1.0</code>. Using <code>post { lottieView.playAnimation() }</code> works for now (<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"459818089\" data-permission-text=\"Title is private\" data-url=\"https://github.com/airbnb/lottie-android/issues/1284\" data-hovercard-type=\"issue\" data-hovercard-url=\"/airbnb/lottie-android/issues/1284/hovercard?comment_id=507229013&amp;comment_type=issue_comment\" href=\"https://github.com/airbnb/lottie-android/issues/1284#issuecomment-507229013\">#1284 (comment)</a>).</p>", "createdAt": "2019-10-21T23:16:55Z", "publishedAt": "2019-10-21T23:16:55Z", "lastEditedAt": null, "updatedAt": "2019-10-21T23:16:55Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 4127, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "I'm still seeing this in 3.1.0.", "sentSegmented": ["i", "'m", "still", "seeing", "this", "in", "3.1.0"], "sentSegmentedWithoutStops": ["'m", "still", "seeing", "3.1.0"], "sentSegmentedWithoutStopsStemmed": ["'m", "still", "see", "3.1.0"]}, {"number": 4128, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Using post { lottieView.playAnimation() } works for now (#1284 (comment)).", "sentSegmented": ["using", "post", "lottieview.playanimation", "works", "for", "now", "1284", "comment"], "sentSegmentedWithoutStops": ["using", "post", "lottieview.playanimation", "works", "1284", "comment"], "sentSegmentedWithoutStopsStemmed": ["use", "post", "lottieview.playanim", "work", "1284", "comment"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDU4MzA5ODg1OA==", "author": {"login": "DavidDTA"}, "body": "I am likewise still seeing #1284 in 3.3.1", "bodyText": "I am likewise still seeing #1284 in 3.3.1", "bodyHTML": "<p>I am likewise still seeing <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"459818089\" data-permission-text=\"Title is private\" data-url=\"https://github.com/airbnb/lottie-android/issues/1284\" data-hovercard-type=\"issue\" data-hovercard-url=\"/airbnb/lottie-android/issues/1284/hovercard\" href=\"https://github.com/airbnb/lottie-android/issues/1284\">#1284</a> in 3.3.1</p>", "createdAt": "2020-02-06T20:37:01Z", "publishedAt": "2020-02-06T20:37:01Z", "lastEditedAt": "2020-02-06T21:16:24Z", "updatedAt": "2020-02-06T21:16:24Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 4129, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "I am likewise still seeing #1284 in 3.3.1", "sentSegmented": ["i", "am", "likewise", "still", "seeing", "1284", "in", "3.3.1"], "sentSegmentedWithoutStops": ["likewise", "still", "seeing", "1284", "3.3.1"], "sentSegmentedWithoutStopsStemmed": ["likewis", "still", "see", "1284", "3.3.1"]}]}}], "pageInfo": {"endCursor": "Y3Vyc29yOnYyOpHOIsFh6g==", "hasNextPage": false}, "totalCount": 7}, "labels": {"edges": [{"node": {"createdAt": "2018-02-12T07:36:27Z", "name": "Help wanted"}}]}, "milestone": null, "reactions": {"edges": []}, "state": "CLOSED", "titleSegmented": ["recycleview", "wasanimatingwhendetached", "is", "n't", "set", "to", "false", "when", "view", "is", "attached"], "titleSegmentedWithoutStops": ["recycleview", "wasanimatingwhendetached", "n't", "set", "false", "view", "attached"], "titleSegmentedWithoutStopsStemmed": ["recycleview", "wasanimatingwhendetach", "n't", "set", "fals", "view", "attach"], "bodyParsed": [{"number": 3920, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "We have a related issue created few hours ago.", "sentSegmented": ["we", "have", "a", "related", "issue", "created", "few", "hours", "ago"], "sentSegmentedWithoutStops": ["related", "issue", "created", "hours", "ago"], "sentSegmentedWithoutStopsStemmed": ["relat", "issu", "creat", "hour", "ago"]}, {"number": 3921, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "But the main issue isn't highlighted/described enough inside of the ticket.", "sentSegmented": ["but", "the", "main", "issue", "is", "n't", "highlighted/described", "enough", "inside", "of", "the", "ticket"], "sentSegmentedWithoutStops": ["main", "issue", "n't", "highlighted/described", "enough", "inside", "ticket"], "sentSegmentedWithoutStopsStemmed": ["main", "issu", "n't", "highlighted/describ", "enough", "insid", "ticket"]}, {"number": 3922, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Let's start:", "sentSegmented": ["let", "'s", "start"], "sentSegmentedWithoutStops": ["let", "'s", "start"], "sentSegmentedWithoutStopsStemmed": ["let", "'s", "start"]}, {"number": 3923, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "I'm using LottieAnimationView.java inside RecyclerView.java.", "sentSegmented": ["i", "'m", "using", "lottieanimationview.java", "inside", "recyclerview.java"], "sentSegmentedWithoutStops": ["'m", "using", "lottieanimationview.java", "inside", "recyclerview.java"], "sentSegmentedWithoutStopsStemmed": ["'m", "use", "lottieanimationview.java", "insid", "recyclerview.java"]}, {"number": 3924, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "In my code every third item has an animation running, I'm operating with a dataset containing 60 items.", "sentSegmented": ["in", "my", "code", "every", "third", "item", "has", "an", "animation", "running", "i", "'m", "operating", "with", "a", "dataset", "containing", "60", "items"], "sentSegmentedWithoutStops": ["code", "every", "third", "item", "animation", "running", "'m", "operating", "dataset", "containing", "60", "items"], "sentSegmentedWithoutStopsStemmed": ["code", "everi", "third", "item", "anim", "run", "'m", "oper", "dataset", "contain", "60", "item"]}, {"number": 3925, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "When LottieAnimationView.java is playing an animation and user starts scrolling  we receive a onDetachedFromWindow() (in case if view scroll offset is big enough).", "sentSegmented": ["when", "lottieanimationview.java", "is", "playing", "an", "animation", "and", "user", "starts", "scrolling", "we", "receive", "a", "ondetachedfromwindow", "in", "case", "if", "view", "scroll", "offset", "is", "big", "enough"], "sentSegmentedWithoutStops": ["lottieanimationview.java", "playing", "animation", "user", "starts", "scrolling", "receive", "ondetachedfromwindow", "case", "view", "scroll", "offset", "big", "enough"], "sentSegmentedWithoutStopsStemmed": ["lottieanimationview.java", "play", "anim", "user", "start", "scroll", "receiv", "ondetachedfromwindow", "case", "view", "scroll", "offset", "big", "enough"]}, {"number": 3926, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "@Override ", "sentSegmented": ["override"], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 3927, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "protected void onDetachedFromWindow() {", "sentSegmented": ["protected", "void", "ondetachedfromwindow"], "sentSegmentedWithoutStops": ["ondetachedfromwindow"], "sentSegmentedWithoutStopsStemmed": ["ondetachedfromwindow"]}, {"number": 3928, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    if (isAnimating()) {", "sentSegmented": ["if", "isanimating"], "sentSegmentedWithoutStops": ["isanimating"], "sentSegmentedWithoutStopsStemmed": ["isanim"]}, {"number": 3929, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "      cancelAnimation();", "sentSegmented": ["cancelanimation"], "sentSegmentedWithoutStops": ["cancelanimation"], "sentSegmentedWithoutStopsStemmed": ["cancelanim"]}, {"number": 3930, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "      wasAnimatingWhenDetached = true;", "sentSegmented": ["wasanimatingwhendetached", "true"], "sentSegmentedWithoutStops": ["wasanimatingwhendetached"], "sentSegmentedWithoutStopsStemmed": ["wasanimatingwhendetach"]}, {"number": 3931, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 3932, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    super.onDetachedFromWindow();", "sentSegmented": ["super.ondetachedfromwindow"], "sentSegmentedWithoutStops": ["super.ondetachedfromwindow"], "sentSegmentedWithoutStopsStemmed": ["super.ondetachedfromwindow"]}, {"number": 3933, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "  }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 3934, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Here we are setting wasAnimatingWhenDetached to true.", "sentSegmented": ["here", "we", "are", "setting", "wasanimatingwhendetached", "to", "true"], "sentSegmentedWithoutStops": ["setting", "wasanimatingwhendetached", "true"], "sentSegmentedWithoutStopsStemmed": ["set", "wasanimatingwhendetach", "true"]}, {"number": 3935, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Afterwards, when user scrolls again and returns to the same item - onAttachedToWindow() callback is called:", "sentSegmented": ["afterwards", "when", "user", "scrolls", "again", "and", "returns", "to", "the", "same", "item", "onattachedtowindow", "callback", "is", "called"], "sentSegmentedWithoutStops": ["afterwards", "user", "scrolls", "returns", "item", "onattachedtowindow", "callback", "called"], "sentSegmentedWithoutStopsStemmed": ["afterward", "user", "scroll", "return", "item", "onattachedtowindow", "callback", "call"]}, {"number": 3936, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "@Override protected void onAttachedToWindow() {", "sentSegmented": ["override", "protected", "void", "onattachedtowindow"], "sentSegmentedWithoutStops": ["onattachedtowindow"], "sentSegmentedWithoutStopsStemmed": ["onattachedtowindow"]}, {"number": 3937, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    super.onAttachedToWindow();", "sentSegmented": ["super.onattachedtowindow"], "sentSegmentedWithoutStops": ["super.onattachedtowindow"], "sentSegmentedWithoutStopsStemmed": ["super.onattachedtowindow"]}, {"number": 3938, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    if (autoPlay || wasAnimatingWhenDetached) {", "sentSegmented": ["if", "autoplay", "wasanimatingwhendetached"], "sentSegmentedWithoutStops": ["autoplay", "wasanimatingwhendetached"], "sentSegmentedWithoutStopsStemmed": ["autoplay", "wasanimatingwhendetach"]}, {"number": 3939, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "      playAnimation();", "sentSegmented": ["playanimation"], "sentSegmentedWithoutStops": ["playanimation"], "sentSegmentedWithoutStopsStemmed": ["playanim"]}, {"number": 3940, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "      // Autoplay from xml should only apply once.", "sentSegmented": ["autoplay", "from", "xml", "should", "only", "apply", "once"], "sentSegmentedWithoutStops": ["autoplay", "xml", "apply"], "sentSegmentedWithoutStopsStemmed": ["autoplay", "xml", "appli"]}, {"number": 3941, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "      autoPlay = false;", "sentSegmented": ["autoplay", "false"], "sentSegmentedWithoutStops": ["autoplay"], "sentSegmentedWithoutStopsStemmed": ["autoplay"]}, {"number": 3942, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 3943, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {", "sentSegmented": ["if", "build.version.sdk_int", "build.version_codes.m"], "sentSegmentedWithoutStops": ["build.version.sdk_int", "build.version_codes.m"], "sentSegmentedWithoutStopsStemmed": ["build.version.sdk_int", "build.version_codes.m"]}, {"number": 3944, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "      // This is needed to mimic newer platform behavior.", "sentSegmented": ["this", "is", "needed", "to", "mimic", "newer", "platform", "behavior"], "sentSegmentedWithoutStops": ["needed", "mimic", "newer", "platform", "behavior"], "sentSegmentedWithoutStopsStemmed": ["need", "mimic", "newer", "platform", "behavior"]}, {"number": 3945, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "      // https://stackoverflow.com/a/53625860/715633", "sentSegmented": ["https", "//stackoverflow.com/a/53625860/715633"], "sentSegmentedWithoutStops": ["https", "//stackoverflow.com/a/53625860/715633"], "sentSegmentedWithoutStopsStemmed": ["http", "//stackoverflow.com/a/53625860/715633"]}, {"number": 3946, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "      onVisibilityChanged(this, getVisibility());", "sentSegmented": ["onvisibilitychanged", "this", "getvisibility"], "sentSegmentedWithoutStops": ["onvisibilitychanged", "getvisibility"], "sentSegmentedWithoutStopsStemmed": ["onvisibilitychang", "getvis"]}, {"number": 3947, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 3948, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "  }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 3949, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "In this callback we are relying on wasAnimatingWhenDetached and in our case we will play animation which wasn't finished.", "sentSegmented": ["in", "this", "callback", "we", "are", "relying", "on", "wasanimatingwhendetached", "and", "in", "our", "case", "we", "will", "play", "animation", "which", "was", "n't", "finished"], "sentSegmentedWithoutStops": ["callback", "relying", "wasanimatingwhendetached", "case", "play", "animation", "n't", "finished"], "sentSegmentedWithoutStopsStemmed": ["callback", "reli", "wasanimatingwhendetach", "case", "play", "anim", "n't", "finish"]}, {"number": 3950, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Until now everything was pretty ok, we are restarting animation which wasn't finished - pretty logical.", "sentSegmented": ["until", "now", "everything", "was", "pretty", "ok", "we", "are", "restarting", "animation", "which", "was", "n't", "finished", "pretty", "logical"], "sentSegmentedWithoutStops": ["everything", "pretty", "ok", "restarting", "animation", "n't", "finished", "pretty", "logical"], "sentSegmentedWithoutStopsStemmed": ["everyth", "pretti", "ok", "restart", "anim", "n't", "finish", "pretti", "logic"]}, {"number": 3951, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "But we aren't setting wasAnimatingWhenDetached flag to false - and that has some side effects.", "sentSegmented": ["but", "we", "are", "n't", "setting", "wasanimatingwhendetached", "flag", "to", "false", "and", "that", "has", "some", "side", "effects"], "sentSegmentedWithoutStops": ["n't", "setting", "wasanimatingwhendetached", "flag", "false", "side", "effects"], "sentSegmentedWithoutStopsStemmed": ["n't", "set", "wasanimatingwhendetach", "flag", "fals", "side", "effect"]}, {"number": 3952, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "In example we scroll back and forth, basically just returning to the same item - and it will again go through onDetachedFromWindow() && onAttachedToWindow()callbacks.", "sentSegmented": ["in", "example", "we", "scroll", "back", "and", "forth", "basically", "just", "returning", "to", "the", "same", "item", "and", "it", "will", "again", "go", "through", "ondetachedfromwindow", "onattachedtowindow", "callbacks"], "sentSegmentedWithoutStops": ["example", "scroll", "back", "forth", "basically", "returning", "item", "go", "ondetachedfromwindow", "onattachedtowindow", "callbacks"], "sentSegmentedWithoutStopsStemmed": ["exampl", "scroll", "back", "forth", "basic", "return", "item", "go", "ondetachedfromwindow", "onattachedtowindow", "callback"]}, {"number": 3953, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "And when the onAttachedToWindow() callback will be triggered we will re-run the animation again, evenif it was finished, which isn't the desired behavior(at least as I see it).", "sentSegmented": ["and", "when", "the", "onattachedtowindow", "callback", "will", "be", "triggered", "we", "will", "re-run", "the", "animation", "again", "evenif", "it", "was", "finished", "which", "is", "n't", "the", "desired", "behavior", "at", "least", "as", "i", "see", "it"], "sentSegmentedWithoutStops": ["onattachedtowindow", "callback", "triggered", "re-run", "animation", "evenif", "finished", "n't", "desired", "behavior", "least", "see"], "sentSegmentedWithoutStopsStemmed": ["onattachedtowindow", "callback", "trigger", "re-run", "anim", "evenif", "finish", "n't", "desir", "behavior", "least", "see"]}, {"number": 3954, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "That will happen because wasAnimatingWhenDetached isn't set to false in onAttachedToWindow() callback.", "sentSegmented": ["that", "will", "happen", "because", "wasanimatingwhendetached", "is", "n't", "set", "to", "false", "in", "onattachedtowindow", "callback"], "sentSegmentedWithoutStops": ["happen", "wasanimatingwhendetached", "n't", "set", "false", "onattachedtowindow", "callback"], "sentSegmentedWithoutStopsStemmed": ["happen", "wasanimatingwhendetach", "n't", "set", "fals", "onattachedtowindow", "callback"]}, {"number": 3955, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Here is an example how it works in real-life(almost) app.", "sentSegmented": ["here", "is", "an", "example", "how", "it", "works", "in", "real-life", "almost", "app"], "sentSegmentedWithoutStops": ["example", "works", "real-life", "almost", "app"], "sentSegmentedWithoutStopsStemmed": ["exampl", "work", "real-lif", "almost", "app"]}, {"number": 3956, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Video is attached as link on google drive as Github doesn't supports mp4.", "sentSegmented": ["video", "is", "attached", "as", "link", "on", "google", "drive", "as", "github", "does", "n't", "supports", "mp4"], "sentSegmentedWithoutStops": ["video", "attached", "link", "google", "drive", "github", "n't", "supports", "mp4"], "sentSegmentedWithoutStopsStemmed": ["video", "attach", "link", "googl", "drive", "github", "n't", "support", "mp4"]}, {"number": 3957, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "So, as you can see I have the bells animation which should be played only once.", "sentSegmented": ["so", "as", "you", "can", "see", "i", "have", "the", "bells", "animation", "which", "should", "be", "played", "only", "once"], "sentSegmentedWithoutStops": ["see", "bells", "animation", "played"], "sentSegmentedWithoutStopsStemmed": ["see", "bell", "anim", "play"]}, {"number": 3958, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "At first I want to show normal/desired flow:", "sentSegmented": ["at", "first", "i", "want", "to", "show", "normal/desired", "flow"], "sentSegmentedWithoutStops": ["first", "want", "show", "normal/desired", "flow"], "sentSegmentedWithoutStopsStemmed": ["first", "want", "show", "normal/desir", "flow"]}, {"number": 3959, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "User scrolls to an item with animation", "sentSegmented": ["user", "scrolls", "to", "an", "item", "with", "animation"], "sentSegmentedWithoutStops": ["user", "scrolls", "item", "animation"], "sentSegmentedWithoutStopsStemmed": ["user", "scroll", "item", "anim"]}, {"number": 3960, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Animation plays till it is finished", "sentSegmented": ["animation", "plays", "till", "it", "is", "finished"], "sentSegmentedWithoutStops": ["animation", "plays", "till", "finished"], "sentSegmentedWithoutStopsStemmed": ["anim", "play", "till", "finish"]}, {"number": 3961, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "User scrolls back and forth but animation doesn't restarts", "sentSegmented": ["user", "scrolls", "back", "and", "forth", "but", "animation", "does", "n't", "restarts"], "sentSegmentedWithoutStops": ["user", "scrolls", "back", "forth", "animation", "n't", "restarts"], "sentSegmentedWithoutStopsStemmed": ["user", "scroll", "back", "forth", "anim", "n't", "restart"]}, {"number": 3962, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Afterwards I wanna show wrong flow:", "sentSegmented": ["afterwards", "i", "wan", "na", "show", "wrong", "flow"], "sentSegmentedWithoutStops": ["afterwards", "wan", "na", "show", "wrong", "flow"], "sentSegmentedWithoutStopsStemmed": ["afterward", "wan", "na", "show", "wrong", "flow"]}, {"number": 3963, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "User scrolls to an item with animation", "sentSegmented": ["user", "scrolls", "to", "an", "item", "with", "animation"], "sentSegmentedWithoutStops": ["user", "scrolls", "item", "animation"], "sentSegmentedWithoutStopsStemmed": ["user", "scroll", "item", "anim"]}, {"number": 3964, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Animation starts", "sentSegmented": ["animation", "starts"], "sentSegmentedWithoutStops": ["animation", "starts"], "sentSegmentedWithoutStopsStemmed": ["anim", "start"]}, {"number": 3965, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "User starts scrolling and animation is cancelled", "sentSegmented": ["user", "starts", "scrolling", "and", "animation", "is", "cancelled"], "sentSegmentedWithoutStops": ["user", "starts", "scrolling", "animation", "cancelled"], "sentSegmentedWithoutStopsStemmed": ["user", "start", "scroll", "anim", "cancel"]}, {"number": 3966, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "User scrolls back to that animation item and animation re-runs and is finished.", "sentSegmented": ["user", "scrolls", "back", "to", "that", "animation", "item", "and", "animation", "re-runs", "and", "is", "finished"], "sentSegmentedWithoutStops": ["user", "scrolls", "back", "animation", "item", "animation", "re-runs", "finished"], "sentSegmentedWithoutStopsStemmed": ["user", "scroll", "back", "anim", "item", "anim", "re-run", "finish"]}, {"number": 3967, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "We end up in finished animation state.", "sentSegmented": ["we", "end", "up", "in", "finished", "animation", "state"], "sentSegmentedWithoutStops": ["end", "finished", "animation", "state"], "sentSegmentedWithoutStopsStemmed": ["end", "finish", "anim", "state"]}, {"number": 3968, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Every next time user scrolls back and forth - animation re-runs.", "sentSegmented": ["every", "next", "time", "user", "scrolls", "back", "and", "forth", "animation", "re-runs"], "sentSegmentedWithoutStops": ["every", "next", "time", "user", "scrolls", "back", "forth", "animation", "re-runs"], "sentSegmentedWithoutStopsStemmed": ["everi", "next", "time", "user", "scroll", "back", "forth", "anim", "re-run"]}, {"number": 3969, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "That is not desired behavior(IMHO).", "sentSegmented": ["that", "is", "not", "desired", "behavior", "imho"], "sentSegmentedWithoutStops": ["desired", "behavior", "imho"], "sentSegmentedWithoutStopsStemmed": ["desir", "behavior", "imho"]}, {"number": 3970, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "I've cloned lottie project and imported it as module to mine project.", "sentSegmented": ["i", "'ve", "cloned", "lottie", "project", "and", "imported", "it", "as", "module", "to", "mine", "project"], "sentSegmentedWithoutStops": ["'ve", "cloned", "lottie", "project", "imported", "module", "mine", "project"], "sentSegmentedWithoutStopsStemmed": ["'ve", "clone", "lotti", "project", "import", "modul", "mine", "project"]}, {"number": 3971, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "I have an idea how that could be fixed(if thats a bug of course).", "sentSegmented": ["i", "have", "an", "idea", "how", "that", "could", "be", "fixed", "if", "thats", "a", "bug", "of", "course"], "sentSegmentedWithoutStops": ["idea", "could", "fixed", "thats", "bug", "course"], "sentSegmentedWithoutStopsStemmed": ["idea", "could", "fix", "that", "bug", "cours"]}, {"number": 3972, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "We can add following line to onAttachedToWindow() callback:", "sentSegmented": ["we", "can", "add", "following", "line", "to", "onattachedtowindow", "callback"], "sentSegmentedWithoutStops": ["add", "following", "line", "onattachedtowindow", "callback"], "sentSegmentedWithoutStopsStemmed": ["add", "follow", "line", "onattachedtowindow", "callback"]}, {"number": 3973, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "@Override ", "sentSegmented": ["override"], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 3974, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "protected void onAttachedToWindow() {", "sentSegmented": ["protected", "void", "onattachedtowindow"], "sentSegmentedWithoutStops": ["onattachedtowindow"], "sentSegmentedWithoutStopsStemmed": ["onattachedtowindow"]}, {"number": 3975, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    super.onAttachedToWindow();", "sentSegmented": ["super.onattachedtowindow"], "sentSegmentedWithoutStops": ["super.onattachedtowindow"], "sentSegmentedWithoutStopsStemmed": ["super.onattachedtowindow"]}, {"number": 3976, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    if (autoPlay || wasAnimatingWhenDetached) {", "sentSegmented": ["if", "autoplay", "wasanimatingwhendetached"], "sentSegmentedWithoutStops": ["autoplay", "wasanimatingwhendetached"], "sentSegmentedWithoutStopsStemmed": ["autoplay", "wasanimatingwhendetach"]}, {"number": 3977, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "      playAnimation();", "sentSegmented": ["playanimation"], "sentSegmentedWithoutStops": ["playanimation"], "sentSegmentedWithoutStopsStemmed": ["playanim"]}, {"number": 3978, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "      // Autoplay from xml should only apply once.", "sentSegmented": ["autoplay", "from", "xml", "should", "only", "apply", "once"], "sentSegmentedWithoutStops": ["autoplay", "xml", "apply"], "sentSegmentedWithoutStopsStemmed": ["autoplay", "xml", "appli"]}, {"number": 3979, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "      autoPlay = false;", "sentSegmented": ["autoplay", "false"], "sentSegmentedWithoutStops": ["autoplay"], "sentSegmentedWithoutStopsStemmed": ["autoplay"]}, {"number": 3980, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "     // this one line could be used to reset our flag", "sentSegmented": ["this", "one", "line", "could", "be", "used", "to", "reset", "our", "flag"], "sentSegmentedWithoutStops": ["one", "line", "could", "used", "reset", "flag"], "sentSegmentedWithoutStopsStemmed": ["one", "line", "could", "use", "reset", "flag"]}, {"number": 3981, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "      wasAnimatingWhenDetached = false;", "sentSegmented": ["wasanimatingwhendetached", "false"], "sentSegmentedWithoutStops": ["wasanimatingwhendetached"], "sentSegmentedWithoutStopsStemmed": ["wasanimatingwhendetach"]}, {"number": 3982, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 3983, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {", "sentSegmented": ["if", "build.version.sdk_int", "build.version_codes.m"], "sentSegmentedWithoutStops": ["build.version.sdk_int", "build.version_codes.m"], "sentSegmentedWithoutStopsStemmed": ["build.version.sdk_int", "build.version_codes.m"]}, {"number": 3984, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "      // This is needed to mimic newer platform behavior.", "sentSegmented": ["this", "is", "needed", "to", "mimic", "newer", "platform", "behavior"], "sentSegmentedWithoutStops": ["needed", "mimic", "newer", "platform", "behavior"], "sentSegmentedWithoutStopsStemmed": ["need", "mimic", "newer", "platform", "behavior"]}, {"number": 3985, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "      // https://stackoverflow.com/a/53625860/715633", "sentSegmented": ["https", "//stackoverflow.com/a/53625860/715633"], "sentSegmentedWithoutStops": ["https", "//stackoverflow.com/a/53625860/715633"], "sentSegmentedWithoutStopsStemmed": ["http", "//stackoverflow.com/a/53625860/715633"]}, {"number": 3986, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "      onVisibilityChanged(this, getVisibility());", "sentSegmented": ["onvisibilitychanged", "this", "getvisibility"], "sentSegmentedWithoutStops": ["onvisibilitychanged", "getvisibility"], "sentSegmentedWithoutStopsStemmed": ["onvisibilitychang", "getvis"]}, {"number": 3987, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 3988, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "  }", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 3989, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "I haven't analyzed other cases, where this fix could create issues.", "sentSegmented": ["i", "have", "n't", "analyzed", "other", "cases", "where", "this", "fix", "could", "create", "issues"], "sentSegmentedWithoutStops": ["n't", "analyzed", "cases", "fix", "could", "create", "issues"], "sentSegmentedWithoutStopsStemmed": ["n't", "analyz", "case", "fix", "could", "creat", "issu"]}, {"number": 3990, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "But I'm almost sure other cases do not exist.", "sentSegmented": ["but", "i", "'m", "almost", "sure", "other", "cases", "do", "not", "exist"], "sentSegmentedWithoutStops": ["'m", "almost", "sure", "cases", "exist"], "sentSegmentedWithoutStopsStemmed": ["'m", "almost", "sure", "case", "exist"]}, {"number": 3991, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Anyway it would be great to hear feedback or explanation on that.", "sentSegmented": ["anyway", "it", "would", "be", "great", "to", "hear", "feedback", "or", "explanation", "on", "that"], "sentSegmentedWithoutStops": ["anyway", "would", "great", "hear", "feedback", "explanation"], "sentSegmentedWithoutStopsStemmed": ["anyway", "would", "great", "hear", "feedback", "explan"]}, {"number": 3992, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Animation JSON file attached:", "sentSegmented": ["animation", "json", "file", "attached"], "sentSegmentedWithoutStops": ["animation", "json", "file", "attached"], "sentSegmentedWithoutStopsStemmed": ["anim", "json", "file", "attach"]}, {"number": 3993, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "ringing_bell.json.zip", "sentSegmented": ["ringing_bell.json.zip"], "sentSegmentedWithoutStops": ["ringing_bell.json.zip"], "sentSegmentedWithoutStopsStemmed": ["ringing_bell.json.zip"]}]}