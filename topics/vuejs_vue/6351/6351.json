{"repository": {"owner": {"login": "vuejs"}, "name": "vue", "forkCount": 28402, "stargazerCount": 180532, "createdAt": "2013-07-29T03:24:51Z", "updatedAt": "2021-03-12T08:12:57Z", "repositoryTopics": {"edges": [{"node": {"topic": {"name": "vue"}}}, {"node": {"topic": {"name": "javascript"}}}, {"node": {"topic": {"name": "frontend"}}}, {"node": {"topic": {"name": "framework"}}}]}, "languages": {"edges": [{"node": {"name": "JavaScript"}}, {"node": {"name": "HTML"}}, {"node": {"name": "Shell"}}, {"node": {"name": "CSS"}}, {"node": {"name": "TypeScript"}}, {"node": {"name": "Vue"}}]}, "primaryLanguage": {"name": "JavaScript"}}, "id": "MDU6SXNzdWUyNDk3MDY1MzE=", "number": 6351, "author": {"login": "adamvleggett"}, "title": "Update slot content without rerendering rest of component", "body": "### What problem does this feature solve?\r\nI have developed some components that can generate large amounts of HTML, and allow content to be added via slot. It appears that if the slot content is updated, the render function is called for the component; however, this seems like something that could be avoided through optimization which would significantly improve the performance of my component in some instances.\r\n\r\nIs this possible?\r\n\r\n### What does the proposed API look like?\r\nNot proposing API changes.\r\n\r\n<!-- generated by vue-issues. DO NOT REMOVE -->", "bodyHTML": "<h3>What problem does this feature solve?</h3>\n<p>I have developed some components that can generate large amounts of HTML, and allow content to be added via slot. It appears that if the slot content is updated, the render function is called for the component; however, this seems like something that could be avoided through optimization which would significantly improve the performance of my component in some instances.</p>\n<p>Is this possible?</p>\n<h3>What does the proposed API look like?</h3>\n<p>Not proposing API changes.</p>\n", "bodyText": "What problem does this feature solve?\nI have developed some components that can generate large amounts of HTML, and allow content to be added via slot. It appears that if the slot content is updated, the render function is called for the component; however, this seems like something that could be avoided through optimization which would significantly improve the performance of my component in some instances.\nIs this possible?\nWhat does the proposed API look like?\nNot proposing API changes.", "assignees": {"edges": []}, "createdAt": "2017-08-11T18:00:56Z", "closed": false, "closedAt": null, "lastEditedAt": null, "publishedAt": "2017-08-11T18:00:56Z", "comments": {"edges": [{"node": {"id": "MDEyOklzc3VlQ29tbWVudDMyMTg4Mzc1Mg==", "author": {"login": "adamvleggett"}, "body": "Note: I understand this wouldn't be possible for scoped slots. However, an optimization that might help even for scoped slots would be to only trigger rerender of the child component if the rerender of the parent component generated a delta for the actual slot content.", "bodyText": "Note: I understand this wouldn't be possible for scoped slots. However, an optimization that might help even for scoped slots would be to only trigger rerender of the child component if the rerender of the parent component generated a delta for the actual slot content.", "bodyHTML": "<p>Note: I understand this wouldn't be possible for scoped slots. However, an optimization that might help even for scoped slots would be to only trigger rerender of the child component if the rerender of the parent component generated a delta for the actual slot content.</p>", "createdAt": "2017-08-11T18:17:44Z", "publishedAt": "2017-08-11T18:17:44Z", "lastEditedAt": null, "updatedAt": "2017-08-11T18:17:44Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 4902, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Note: I understand this wouldn't be possible for scoped slots.", "sentSegmented": ["note", "i", "understand", "this", "would", "n't", "be", "possible", "for", "scoped", "slots"], "sentSegmentedWithoutStops": ["note", "understand", "would", "n't", "possible", "scoped", "slots"], "sentSegmentedWithoutStopsStemmed": ["note", "understand", "would", "n't", "possibl", "scope", "slot"]}, {"number": 4903, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "However, an optimization that might help even for scoped slots would be to only trigger rerender of the child component if the rerender of the parent component generated a delta for the actual slot content.", "sentSegmented": ["however", "an", "optimization", "that", "might", "help", "even", "for", "scoped", "slots", "would", "be", "to", "only", "trigger", "rerender", "of", "the", "child", "component", "if", "the", "rerender", "of", "the", "parent", "component", "generated", "a", "delta", "for", "the", "actual", "slot", "content"], "sentSegmentedWithoutStops": ["however", "optimization", "might", "help", "even", "scoped", "slots", "would", "trigger", "rerender", "child", "component", "rerender", "parent", "component", "generated", "delta", "actual", "slot", "content"], "sentSegmentedWithoutStopsStemmed": ["howev", "optim", "might", "help", "even", "scope", "slot", "would", "trigger", "rerend", "child", "compon", "rerend", "parent", "compon", "gener", "delta", "actual", "slot", "content"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDMyNDI2NjA5MA==", "author": {"login": "LinusBorg"}, "body": "Well, I think it would be possible to implement something that would diff slot contents before updateiung the components but - ignoring difficulties in implementing this for the moment, because I can't say much about this right now - it would come with a performance tradeoff:\r\n\r\nWith your proposal, we would save rendering the virtualdom of the child if nothing in the slot changed -\r\n but everytime the diffing of slot content **does** find changes in the slot content, we would be diffing the slot content twice - because after the render function of the child has run, the new vdom has to be diffed again.\r\n\r\nEssentially this means that now, children with big templates and small slot contents would run better, while children with small templates and big slots woudl run worse when changes happen.\r\n\r\nNot sure what is better...\r\n\r\nAlso, technically the child would keep an outdated virtualDOM, because while the content of the slot nodes is the same, the parent created fresh nodes when it re-rendered, so I suspect that this might be a technical hurdle.\r\n  ", "bodyText": "Well, I think it would be possible to implement something that would diff slot contents before updateiung the components but - ignoring difficulties in implementing this for the moment, because I can't say much about this right now - it would come with a performance tradeoff:\nWith your proposal, we would save rendering the virtualdom of the child if nothing in the slot changed -\nbut everytime the diffing of slot content does find changes in the slot content, we would be diffing the slot content twice - because after the render function of the child has run, the new vdom has to be diffed again.\nEssentially this means that now, children with big templates and small slot contents would run better, while children with small templates and big slots woudl run worse when changes happen.\nNot sure what is better...\nAlso, technically the child would keep an outdated virtualDOM, because while the content of the slot nodes is the same, the parent created fresh nodes when it re-rendered, so I suspect that this might be a technical hurdle.", "bodyHTML": "<p>Well, I think it would be possible to implement something that would diff slot contents before updateiung the components but - ignoring difficulties in implementing this for the moment, because I can't say much about this right now - it would come with a performance tradeoff:</p>\n<p>With your proposal, we would save rendering the virtualdom of the child if nothing in the slot changed -<br>\nbut everytime the diffing of slot content <strong>does</strong> find changes in the slot content, we would be diffing the slot content twice - because after the render function of the child has run, the new vdom has to be diffed again.</p>\n<p>Essentially this means that now, children with big templates and small slot contents would run better, while children with small templates and big slots woudl run worse when changes happen.</p>\n<p>Not sure what is better...</p>\n<p>Also, technically the child would keep an outdated virtualDOM, because while the content of the slot nodes is the same, the parent created fresh nodes when it re-rendered, so I suspect that this might be a technical hurdle.</p>", "createdAt": "2017-08-23T08:55:43Z", "publishedAt": "2017-08-23T08:55:43Z", "lastEditedAt": "2018-01-09T16:03:03Z", "updatedAt": "2018-01-09T16:03:03Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 4904, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Well, I think it would be possible to implement something that would diff slot contents before updateiung the components but - ignoring difficulties in implementing this for the moment, because I can't say much about this right now - it would come with a performance tradeoff:", "sentSegmented": ["well", "i", "think", "it", "would", "be", "possible", "to", "implement", "something", "that", "would", "diff", "slot", "contents", "before", "updateiung", "the", "components", "but", "ignoring", "difficulties", "in", "implementing", "this", "for", "the", "moment", "because", "i", "ca", "n't", "say", "much", "about", "this", "right", "now", "it", "would", "come", "with", "a", "performance", "tradeoff"], "sentSegmentedWithoutStops": ["well", "think", "would", "possible", "implement", "something", "would", "diff", "slot", "contents", "updateiung", "components", "ignoring", "difficulties", "implementing", "moment", "ca", "n't", "say", "much", "right", "would", "come", "performance", "tradeoff"], "sentSegmentedWithoutStopsStemmed": ["well", "think", "would", "possibl", "implement", "someth", "would", "diff", "slot", "content", "updateiung", "compon", "ignor", "difficulti", "implement", "moment", "ca", "n't", "say", "much", "right", "would", "come", "perform", "tradeoff"]}, {"number": 4905, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "With your proposal, we would save rendering the virtualdom of the child if nothing in the slot changed -", "sentSegmented": ["with", "your", "proposal", "we", "would", "save", "rendering", "the", "virtualdom", "of", "the", "child", "if", "nothing", "in", "the", "slot", "changed"], "sentSegmentedWithoutStops": ["proposal", "would", "save", "rendering", "virtualdom", "child", "nothing", "slot", "changed"], "sentSegmentedWithoutStopsStemmed": ["propos", "would", "save", "render", "virtualdom", "child", "noth", "slot", "chang"]}, {"number": 4906, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "but everytime the diffing of slot content does find changes in the slot content, we would be diffing the slot content twice - because after the render function of the child has run, the new vdom has to be diffed again.", "sentSegmented": ["but", "everytime", "the", "diffing", "of", "slot", "content", "does", "find", "changes", "in", "the", "slot", "content", "we", "would", "be", "diffing", "the", "slot", "content", "twice", "because", "after", "the", "render", "function", "of", "the", "child", "has", "run", "the", "new", "vdom", "has", "to", "be", "diffed", "again"], "sentSegmentedWithoutStops": ["everytime", "diffing", "slot", "content", "find", "changes", "slot", "content", "would", "diffing", "slot", "content", "twice", "render", "function", "child", "run", "new", "vdom", "diffed"], "sentSegmentedWithoutStopsStemmed": ["everytim", "dif", "slot", "content", "find", "chang", "slot", "content", "would", "dif", "slot", "content", "twice", "render", "function", "child", "run", "new", "vdom", "dif"]}, {"number": 4907, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Essentially this means that now, children with big templates and small slot contents would run better, while children with small templates and big slots woudl run worse when changes happen.", "sentSegmented": ["essentially", "this", "means", "that", "now", "children", "with", "big", "templates", "and", "small", "slot", "contents", "would", "run", "better", "while", "children", "with", "small", "templates", "and", "big", "slots", "woudl", "run", "worse", "when", "changes", "happen"], "sentSegmentedWithoutStops": ["essentially", "means", "children", "big", "templates", "small", "slot", "contents", "would", "run", "better", "children", "small", "templates", "big", "slots", "woudl", "run", "worse", "changes", "happen"], "sentSegmentedWithoutStopsStemmed": ["essenti", "mean", "children", "big", "templat", "small", "slot", "content", "would", "run", "better", "children", "small", "templat", "big", "slot", "woudl", "run", "wors", "chang", "happen"]}, {"number": 4908, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Not sure what is better...", "sentSegmented": ["not", "sure", "what", "is", "better"], "sentSegmentedWithoutStops": ["sure", "better"], "sentSegmentedWithoutStopsStemmed": ["sure", "better"]}, {"number": 4909, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Also, technically the child would keep an outdated virtualDOM, because while the content of the slot nodes is the same, the parent created fresh nodes when it re-rendered, so I suspect that this might be a technical hurdle.", "sentSegmented": ["also", "technically", "the", "child", "would", "keep", "an", "outdated", "virtualdom", "because", "while", "the", "content", "of", "the", "slot", "nodes", "is", "the", "same", "the", "parent", "created", "fresh", "nodes", "when", "it", "re-rendered", "so", "i", "suspect", "that", "this", "might", "be", "a", "technical", "hurdle"], "sentSegmentedWithoutStops": ["also", "technically", "child", "would", "keep", "outdated", "virtualdom", "content", "slot", "nodes", "parent", "created", "fresh", "nodes", "re-rendered", "suspect", "might", "technical", "hurdle"], "sentSegmentedWithoutStopsStemmed": ["also", "technic", "child", "would", "keep", "outdat", "virtualdom", "content", "slot", "node", "parent", "creat", "fresh", "node", "re-rend", "suspect", "might", "technic", "hurdl"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDMyNDMzMzMxNQ==", "author": {"login": "adamvleggett"}, "body": "In my case it's a slot that the component uses in a v-for loop to apply to hundreds or more repeats. In this case it's unquestionably faster to calculate the delta. I wonder if this can be reasonably detected.", "bodyText": "In my case it's a slot that the component uses in a v-for loop to apply to hundreds or more repeats. In this case it's unquestionably faster to calculate the delta. I wonder if this can be reasonably detected.", "bodyHTML": "<p>In my case it's a slot that the component uses in a v-for loop to apply to hundreds or more repeats. In this case it's unquestionably faster to calculate the delta. I wonder if this can be reasonably detected.</p>", "createdAt": "2017-08-23T13:35:30Z", "publishedAt": "2017-08-23T13:35:30Z", "lastEditedAt": null, "updatedAt": "2017-08-23T13:35:30Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 4910, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "In my case it's a slot that the component uses in a v-for loop to apply to hundreds or more repeats.", "sentSegmented": ["in", "my", "case", "it", "'s", "a", "slot", "that", "the", "component", "uses", "in", "a", "v-for", "loop", "to", "apply", "to", "hundreds", "or", "more", "repeats"], "sentSegmentedWithoutStops": ["case", "'s", "slot", "component", "uses", "v-for", "loop", "apply", "hundreds", "repeats"], "sentSegmentedWithoutStopsStemmed": ["case", "'s", "slot", "compon", "use", "v-for", "loop", "appli", "hundr", "repeat"]}, {"number": 4911, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "In this case it's unquestionably faster to calculate the delta.", "sentSegmented": ["in", "this", "case", "it", "'s", "unquestionably", "faster", "to", "calculate", "the", "delta"], "sentSegmentedWithoutStops": ["case", "'s", "unquestionably", "faster", "calculate", "delta"], "sentSegmentedWithoutStopsStemmed": ["case", "'s", "unquestion", "faster", "calcul", "delta"]}, {"number": 4912, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "I wonder if this can be reasonably detected.", "sentSegmented": ["i", "wonder", "if", "this", "can", "be", "reasonably", "detected"], "sentSegmentedWithoutStops": ["wonder", "reasonably", "detected"], "sentSegmentedWithoutStopsStemmed": ["wonder", "reason", "detect"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDMyNDMzNDc0Ng==", "author": {"login": "LinusBorg"}, "body": "> I wonder if this can be reasonably detected. \r\n\r\nHardly, and if so, only during compile time, not runtime. That would require some analysis during compilation that would have to derminate when a template is \"expensive, then set some flag so the component resolts to slot diffing during runtime, and doesn't for cheap components.\r\n\r\nSounds easy but measuring \"expensiveness\" would be very tricky considering `v-if` having a big impactr on when a temnplate is actually expensive and when not, and the small fact that we cannot statically analyse during compilation  how big the arrays that you render will be during runtime, etc. pp.\r\n\r\nA new API would be thinkable to set that flag manually, at least in theory.", "bodyText": "I wonder if this can be reasonably detected.\n\nHardly, and if so, only during compile time, not runtime. That would require some analysis during compilation that would have to derminate when a template is \"expensive, then set some flag so the component resolts to slot diffing during runtime, and doesn't for cheap components.\nSounds easy but measuring \"expensiveness\" would be very tricky considering v-if having a big impactr on when a temnplate is actually expensive and when not, and the small fact that we cannot statically analyse during compilation  how big the arrays that you render will be during runtime, etc. pp.\nA new API would be thinkable to set that flag manually, at least in theory.", "bodyHTML": "<blockquote>\n<p>I wonder if this can be reasonably detected.</p>\n</blockquote>\n<p>Hardly, and if so, only during compile time, not runtime. That would require some analysis during compilation that would have to derminate when a template is \"expensive, then set some flag so the component resolts to slot diffing during runtime, and doesn't for cheap components.</p>\n<p>Sounds easy but measuring \"expensiveness\" would be very tricky considering <code>v-if</code> having a big impactr on when a temnplate is actually expensive and when not, and the small fact that we cannot statically analyse during compilation  how big the arrays that you render will be during runtime, etc. pp.</p>\n<p>A new API would be thinkable to set that flag manually, at least in theory.</p>", "createdAt": "2017-08-23T13:39:58Z", "publishedAt": "2017-08-23T13:39:58Z", "lastEditedAt": "2017-08-23T13:42:00Z", "updatedAt": "2017-08-23T13:42:00Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 4913, "isCode": false, "isBlockQuote": true, "blockQuoteDepth": 1, "sent": "I wonder if this can be reasonably detected.", "sentSegmented": ["i", "wonder", "if", "this", "can", "be", "reasonably", "detected"], "sentSegmentedWithoutStops": ["wonder", "reasonably", "detected"], "sentSegmentedWithoutStopsStemmed": ["wonder", "reason", "detect"]}, {"number": 4914, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Hardly, and if so, only during compile time, not runtime.", "sentSegmented": ["hardly", "and", "if", "so", "only", "during", "compile", "time", "not", "runtime"], "sentSegmentedWithoutStops": ["hardly", "compile", "time", "runtime"], "sentSegmentedWithoutStopsStemmed": ["hardli", "compil", "time", "runtim"]}, {"number": 4915, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "That would require some analysis during compilation that would have to derminate when a template is \"expensive, then set some flag so the component resolts to slot diffing during runtime, and doesn't for cheap components.", "sentSegmented": ["that", "would", "require", "some", "analysis", "during", "compilation", "that", "would", "have", "to", "derminate", "when", "a", "template", "is", "expensive", "then", "set", "some", "flag", "so", "the", "component", "resolts", "to", "slot", "diffing", "during", "runtime", "and", "does", "n't", "for", "cheap", "components"], "sentSegmentedWithoutStops": ["would", "require", "analysis", "compilation", "would", "derminate", "template", "expensive", "set", "flag", "component", "resolts", "slot", "diffing", "runtime", "n't", "cheap", "components"], "sentSegmentedWithoutStopsStemmed": ["would", "requir", "analysi", "compil", "would", "dermin", "templat", "expens", "set", "flag", "compon", "resolt", "slot", "dif", "runtim", "n't", "cheap", "compon"]}, {"number": 4916, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Sounds easy but measuring \"expensiveness\" would be very tricky considering v-if having a big impactr on when a temnplate is actually expensive and when not, and the small fact that we cannot statically analyse during compilation  how big the arrays that you render will be during runtime, etc.", "sentSegmented": ["sounds", "easy", "but", "measuring", "expensiveness", "would", "be", "very", "tricky", "considering", "v-if", "having", "a", "big", "impactr", "on", "when", "a", "temnplate", "is", "actually", "expensive", "and", "when", "not", "and", "the", "small", "fact", "that", "we", "can", "not", "statically", "analyse", "during", "compilation", "how", "big", "the", "arrays", "that", "you", "render", "will", "be", "during", "runtime", "etc"], "sentSegmentedWithoutStops": ["sounds", "easy", "measuring", "expensiveness", "would", "tricky", "considering", "v-if", "big", "impactr", "temnplate", "actually", "expensive", "small", "fact", "statically", "analyse", "compilation", "big", "arrays", "render", "runtime", "etc"], "sentSegmentedWithoutStopsStemmed": ["sound", "easi", "measur", "expens", "would", "tricki", "consid", "v-if", "big", "impactr", "temnplat", "actual", "expens", "small", "fact", "static", "analys", "compil", "big", "array", "render", "runtim", "etc"]}, {"number": 4917, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "pp.", "sentSegmented": ["pp"], "sentSegmentedWithoutStops": ["pp"], "sentSegmentedWithoutStopsStemmed": ["pp"]}, {"number": 4918, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "A new API would be thinkable to set that flag manually, at least in theory.", "sentSegmented": ["a", "new", "api", "would", "be", "thinkable", "to", "set", "that", "flag", "manually", "at", "least", "in", "theory"], "sentSegmentedWithoutStops": ["new", "api", "would", "thinkable", "set", "flag", "manually", "least", "theory"], "sentSegmentedWithoutStopsStemmed": ["new", "api", "would", "thinkabl", "set", "flag", "manual", "least", "theori"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDMyNDM2MzAzNg==", "author": {"login": "adamvleggett"}, "body": "I would say if either:\r\n\r\n- the slot is used inside any loop\r\n- the slot contents are smaller than the template\r\n\r\nThen that's a time it's probably worth it to test the delta.\r\n\r\nIn my particular case, it would save me having to make some rather unintuitive changes to the structure of a library that's used by a lot of developers in my company.", "bodyText": "I would say if either:\n\nthe slot is used inside any loop\nthe slot contents are smaller than the template\n\nThen that's a time it's probably worth it to test the delta.\nIn my particular case, it would save me having to make some rather unintuitive changes to the structure of a library that's used by a lot of developers in my company.", "bodyHTML": "<p>I would say if either:</p>\n<ul>\n<li>the slot is used inside any loop</li>\n<li>the slot contents are smaller than the template</li>\n</ul>\n<p>Then that's a time it's probably worth it to test the delta.</p>\n<p>In my particular case, it would save me having to make some rather unintuitive changes to the structure of a library that's used by a lot of developers in my company.</p>", "createdAt": "2017-08-23T14:57:45Z", "publishedAt": "2017-08-23T14:57:45Z", "lastEditedAt": null, "updatedAt": "2017-08-23T14:57:45Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 4919, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "I would say if either:", "sentSegmented": ["i", "would", "say", "if", "either"], "sentSegmentedWithoutStops": ["would", "say", "either"], "sentSegmentedWithoutStopsStemmed": ["would", "say", "either"]}, {"number": 4920, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "the slot is used inside any loop", "sentSegmented": ["the", "slot", "is", "used", "inside", "any", "loop"], "sentSegmentedWithoutStops": ["slot", "used", "inside", "loop"], "sentSegmentedWithoutStopsStemmed": ["slot", "use", "insid", "loop"]}, {"number": 4921, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "the slot contents are smaller than the template", "sentSegmented": ["the", "slot", "contents", "are", "smaller", "than", "the", "template"], "sentSegmentedWithoutStops": ["slot", "contents", "smaller", "template"], "sentSegmentedWithoutStopsStemmed": ["slot", "content", "smaller", "templat"]}, {"number": 4922, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Then that's a time it's probably worth it to test the delta.", "sentSegmented": ["then", "that", "'s", "a", "time", "it", "'s", "probably", "worth", "it", "to", "test", "the", "delta"], "sentSegmentedWithoutStops": ["'s", "time", "'s", "probably", "worth", "test", "delta"], "sentSegmentedWithoutStopsStemmed": ["'s", "time", "'s", "probabl", "worth", "test", "delta"]}, {"number": 4923, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "In my particular case, it would save me having to make some rather unintuitive changes to the structure of a library that's used by a lot of developers in my company.", "sentSegmented": ["in", "my", "particular", "case", "it", "would", "save", "me", "having", "to", "make", "some", "rather", "unintuitive", "changes", "to", "the", "structure", "of", "a", "library", "that", "'s", "used", "by", "a", "lot", "of", "developers", "in", "my", "company"], "sentSegmentedWithoutStops": ["particular", "case", "would", "save", "make", "rather", "unintuitive", "changes", "structure", "library", "'s", "used", "lot", "developers", "company"], "sentSegmentedWithoutStopsStemmed": ["particular", "case", "would", "save", "make", "rather", "unintuit", "chang", "structur", "librari", "'s", "use", "lot", "develop", "compani"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDMyNDM2NDIwMA==", "author": {"login": "adamvleggett"}, "body": "Also, calling the render function is typically much slower than performing a diff on two strings of data.", "bodyText": "Also, calling the render function is typically much slower than performing a diff on two strings of data.", "bodyHTML": "<p>Also, calling the render function is typically much slower than performing a diff on two strings of data.</p>", "createdAt": "2017-08-23T15:01:20Z", "publishedAt": "2017-08-23T15:01:20Z", "lastEditedAt": null, "updatedAt": "2017-08-23T15:01:20Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 4924, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Also, calling the render function is typically much slower than performing a diff on two strings of data.", "sentSegmented": ["also", "calling", "the", "render", "function", "is", "typically", "much", "slower", "than", "performing", "a", "diff", "on", "two", "strings", "of", "data"], "sentSegmentedWithoutStops": ["also", "calling", "render", "function", "typically", "much", "slower", "performing", "diff", "two", "strings", "data"], "sentSegmentedWithoutStopsStemmed": ["also", "call", "render", "function", "typic", "much", "slower", "perform", "diff", "two", "string", "data"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDM1NjMxNTgyMA==", "author": {"login": "rssfrncs"}, "body": "Hi.\r\n\r\nIs this issue still active? ", "bodyText": "Hi.\nIs this issue still active?", "bodyHTML": "<p>Hi.</p>\n<p>Is this issue still active?</p>", "createdAt": "2018-01-09T15:24:28Z", "publishedAt": "2018-01-09T15:24:28Z", "lastEditedAt": null, "updatedAt": "2019-01-23T14:57:22Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 4925, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Hi.", "sentSegmented": ["hi"], "sentSegmentedWithoutStops": ["hi"], "sentSegmentedWithoutStopsStemmed": ["hi"]}, {"number": 4926, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Is this issue still active?", "sentSegmented": ["is", "this", "issue", "still", "active"], "sentSegmentedWithoutStops": ["issue", "still", "active"], "sentSegmentedWithoutStopsStemmed": ["issu", "still", "activ"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDM1NjMxODgwMA==", "author": {"login": "LinusBorg"}, "body": "Yes.", "bodyText": "Yes.", "bodyHTML": "<p>Yes.</p>", "createdAt": "2018-01-09T15:33:52Z", "publishedAt": "2018-01-09T15:33:52Z", "lastEditedAt": null, "updatedAt": "2019-01-23T14:57:28Z", "reactions": {"edges": [{"node": {"content": "THUMBS_UP", "createdAt": "2018-04-13T10:12:57Z"}}]}, "bodyParsed": [{"number": 4927, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Yes.", "sentSegmented": ["yes"], "sentSegmentedWithoutStops": ["yes"], "sentSegmentedWithoutStopsStemmed": ["ye"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDM5Njc1OTYxMQ==", "author": {"login": "JosephSilber"}, "body": "@LinusBorg \r\n\r\n> everytime the diffing of slot content does find changes in the slot content, we would be diffing the slot content twice - because after the render function of the child has run, the new vdom has to be diffed again.\r\n\r\nWould it be possible to introduce a new watcher boundary API? This would be an internal implementation, to which template slot content would compile to.\r\n\r\nThis way, the slot's content wouldn't even have to re-render if the data it depends on doesn't change. Since it doesn't re-render, it doesn't need to be diffed.", "bodyText": "@LinusBorg\n\neverytime the diffing of slot content does find changes in the slot content, we would be diffing the slot content twice - because after the render function of the child has run, the new vdom has to be diffed again.\n\nWould it be possible to introduce a new watcher boundary API? This would be an internal implementation, to which template slot content would compile to.\nThis way, the slot's content wouldn't even have to re-render if the data it depends on doesn't change. Since it doesn't re-render, it doesn't need to be diffed.", "bodyHTML": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/LinusBorg/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/LinusBorg\">@LinusBorg</a></p>\n<blockquote>\n<p>everytime the diffing of slot content does find changes in the slot content, we would be diffing the slot content twice - because after the render function of the child has run, the new vdom has to be diffed again.</p>\n</blockquote>\n<p>Would it be possible to introduce a new watcher boundary API? This would be an internal implementation, to which template slot content would compile to.</p>\n<p>This way, the slot's content wouldn't even have to re-render if the data it depends on doesn't change. Since it doesn't re-render, it doesn't need to be diffed.</p>", "createdAt": "2018-06-12T22:52:39Z", "publishedAt": "2018-06-12T22:52:39Z", "lastEditedAt": "2018-06-13T01:52:29Z", "updatedAt": "2018-06-13T01:52:29Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 4928, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "@LinusBorg", "sentSegmented": ["linusborg"], "sentSegmentedWithoutStops": ["linusborg"], "sentSegmentedWithoutStopsStemmed": ["linusborg"]}, {"number": 4929, "isCode": false, "isBlockQuote": true, "blockQuoteDepth": 1, "sent": "everytime the diffing of slot content does find changes in the slot content, we would be diffing the slot content twice - because after the render function of the child has run, the new vdom has to be diffed again.", "sentSegmented": ["everytime", "the", "diffing", "of", "slot", "content", "does", "find", "changes", "in", "the", "slot", "content", "we", "would", "be", "diffing", "the", "slot", "content", "twice", "because", "after", "the", "render", "function", "of", "the", "child", "has", "run", "the", "new", "vdom", "has", "to", "be", "diffed", "again"], "sentSegmentedWithoutStops": ["everytime", "diffing", "slot", "content", "find", "changes", "slot", "content", "would", "diffing", "slot", "content", "twice", "render", "function", "child", "run", "new", "vdom", "diffed"], "sentSegmentedWithoutStopsStemmed": ["everytim", "dif", "slot", "content", "find", "chang", "slot", "content", "would", "dif", "slot", "content", "twice", "render", "function", "child", "run", "new", "vdom", "dif"]}, {"number": 4930, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Would it be possible to introduce a new watcher boundary API?", "sentSegmented": ["would", "it", "be", "possible", "to", "introduce", "a", "new", "watcher", "boundary", "api"], "sentSegmentedWithoutStops": ["would", "possible", "introduce", "new", "watcher", "boundary", "api"], "sentSegmentedWithoutStopsStemmed": ["would", "possibl", "introduc", "new", "watcher", "boundari", "api"]}, {"number": 4931, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "This would be an internal implementation, to which template slot content would compile to.", "sentSegmented": ["this", "would", "be", "an", "internal", "implementation", "to", "which", "template", "slot", "content", "would", "compile", "to"], "sentSegmentedWithoutStops": ["would", "internal", "implementation", "template", "slot", "content", "would", "compile"], "sentSegmentedWithoutStopsStemmed": ["would", "intern", "implement", "templat", "slot", "content", "would", "compil"]}, {"number": 4932, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "This way, the slot's content wouldn't even have to re-render if the data it depends on doesn't change.", "sentSegmented": ["this", "way", "the", "slot", "'s", "content", "would", "n't", "even", "have", "to", "re-render", "if", "the", "data", "it", "depends", "on", "does", "n't", "change"], "sentSegmentedWithoutStops": ["way", "slot", "'s", "content", "would", "n't", "even", "re-render", "data", "depends", "n't", "change"], "sentSegmentedWithoutStopsStemmed": ["way", "slot", "'s", "content", "would", "n't", "even", "re-rend", "data", "depend", "n't", "chang"]}, {"number": 4933, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Since it doesn't re-render, it doesn't need to be diffed.", "sentSegmented": ["since", "it", "does", "n't", "re-render", "it", "does", "n't", "need", "to", "be", "diffed"], "sentSegmentedWithoutStops": ["since", "n't", "re-render", "n't", "need", "diffed"], "sentSegmentedWithoutStopsStemmed": ["sinc", "n't", "re-rend", "n't", "need", "dif"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDM5Nzg3NjY2NA==", "author": {"login": "JosephSilber"}, "body": "Just to show another use-case of how I bumped into this:\r\n\r\nVue's computed properties currently can't take any arguments. Instead, if you want to use some calculated data in a loop (which is generally where you'd need to pass data into a computed), you have to resort to one of these:\r\n\r\n1. Using a regular method, such as `calculateOrderTotal(order)`.\r\n\r\n    However, using a regular method means that the data is recomputed with every render. That's bad for performance.\r\n\r\n1. Create a separate functional component for the list item, and create an instance of that component for each item in the list, such as `<Order v-for=\"order of orders\" :order=\"order\">`. The component will then only re-render when the data passed to it is changed, which is what we want.\r\n\r\n    However, putting the template in the component is not ideal because **a)** these are usually small snippets that don't really warrant being in their own template **b)** if the component uses a template then it needs its own `.vue` file, which makes this solution feel even heavier than it already is.\r\n\r\n    So the solution I came up with is to have the component only calculate the data, but render all of its HTML via the default slot, thereby forgoing the template altogether. And **now we get to the crux of the issue: if we pass content in the slot to the child component, it will always re-render along with the parent, which means that the data will also be recalculated on every single render**<sup>1</sup>. This totally negates any benefit we got over using a regular method.\r\n\r\nHere's demo in action: https://codepen.io/JosephSilber/pen/MXJZro\r\n\r\n---\r\n\r\n<sup>1</sup> A potential solution would be to have a `computed` property within the child component, but then the component can no longer be functional. When rendering a big list, using functional components makes a huge difference.", "bodyText": "Just to show another use-case of how I bumped into this:\nVue's computed properties currently can't take any arguments. Instead, if you want to use some calculated data in a loop (which is generally where you'd need to pass data into a computed), you have to resort to one of these:\n\n\nUsing a regular method, such as calculateOrderTotal(order).\nHowever, using a regular method means that the data is recomputed with every render. That's bad for performance.\n\n\nCreate a separate functional component for the list item, and create an instance of that component for each item in the list, such as <Order v-for=\"order of orders\" :order=\"order\">. The component will then only re-render when the data passed to it is changed, which is what we want.\nHowever, putting the template in the component is not ideal because a) these are usually small snippets that don't really warrant being in their own template b) if the component uses a template then it needs its own .vue file, which makes this solution feel even heavier than it already is.\nSo the solution I came up with is to have the component only calculate the data, but render all of its HTML via the default slot, thereby forgoing the template altogether. And now we get to the crux of the issue: if we pass content in the slot to the child component, it will always re-render along with the parent, which means that the data will also be recalculated on every single render1. This totally negates any benefit we got over using a regular method.\n\n\nHere's demo in action: https://codepen.io/JosephSilber/pen/MXJZro\n\n1 A potential solution would be to have a computed property within the child component, but then the component can no longer be functional. When rendering a big list, using functional components makes a huge difference.", "bodyHTML": "<p>Just to show another use-case of how I bumped into this:</p>\n<p>Vue's computed properties currently can't take any arguments. Instead, if you want to use some calculated data in a loop (which is generally where you'd need to pass data into a computed), you have to resort to one of these:</p>\n<ol>\n<li>\n<p>Using a regular method, such as <code>calculateOrderTotal(order)</code>.</p>\n<p>However, using a regular method means that the data is recomputed with every render. That's bad for performance.</p>\n</li>\n<li>\n<p>Create a separate functional component for the list item, and create an instance of that component for each item in the list, such as <code>&lt;Order v-for=\"order of orders\" :order=\"order\"&gt;</code>. The component will then only re-render when the data passed to it is changed, which is what we want.</p>\n<p>However, putting the template in the component is not ideal because <strong>a)</strong> these are usually small snippets that don't really warrant being in their own template <strong>b)</strong> if the component uses a template then it needs its own <code>.vue</code> file, which makes this solution feel even heavier than it already is.</p>\n<p>So the solution I came up with is to have the component only calculate the data, but render all of its HTML via the default slot, thereby forgoing the template altogether. And <strong>now we get to the crux of the issue: if we pass content in the slot to the child component, it will always re-render along with the parent, which means that the data will also be recalculated on every single render</strong><sup>1</sup>. This totally negates any benefit we got over using a regular method.</p>\n</li>\n</ol>\n<p>Here's demo in action: <a rel=\"nofollow\" href=\"https://codepen.io/JosephSilber/pen/MXJZro\">https://codepen.io/JosephSilber/pen/MXJZro</a></p>\n<hr>\n<p><sup>1</sup> A potential solution would be to have a <code>computed</code> property within the child component, but then the component can no longer be functional. When rendering a big list, using functional components makes a huge difference.</p>", "createdAt": "2018-06-17T12:47:07Z", "publishedAt": "2018-06-17T12:47:07Z", "lastEditedAt": "2018-06-17T12:49:29Z", "updatedAt": "2018-06-17T12:49:29Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 4934, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Just to show another use-case of how I bumped into this:", "sentSegmented": ["just", "to", "show", "another", "use-case", "of", "how", "i", "bumped", "into", "this"], "sentSegmentedWithoutStops": ["show", "another", "use-case", "bumped"], "sentSegmentedWithoutStopsStemmed": ["show", "anoth", "use-cas", "bump"]}, {"number": 4935, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Vue's computed properties currently can't take any arguments.", "sentSegmented": ["vue", "'s", "computed", "properties", "currently", "ca", "n't", "take", "any", "arguments"], "sentSegmentedWithoutStops": ["vue", "'s", "computed", "properties", "currently", "ca", "n't", "take", "arguments"], "sentSegmentedWithoutStopsStemmed": ["vue", "'s", "comput", "properti", "current", "ca", "n't", "take", "argument"]}, {"number": 4936, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Instead, if you want to use some calculated data in a loop (which is generally where you'd need to pass data into a computed), you have to resort to one of these:", "sentSegmented": ["instead", "if", "you", "want", "to", "use", "some", "calculated", "data", "in", "a", "loop", "which", "is", "generally", "where", "you", "'d", "need", "to", "pass", "data", "into", "a", "computed", "you", "have", "to", "resort", "to", "one", "of", "these"], "sentSegmentedWithoutStops": ["instead", "want", "use", "calculated", "data", "loop", "generally", "'d", "need", "pass", "data", "computed", "resort", "one"], "sentSegmentedWithoutStopsStemmed": ["instead", "want", "use", "calcul", "data", "loop", "gener", "'d", "need", "pass", "data", "comput", "resort", "one"]}, {"number": 4937, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Using a regular method, such as calculateOrderTotal(order).", "sentSegmented": ["using", "a", "regular", "method", "such", "as", "calculateordertotal", "order"], "sentSegmentedWithoutStops": ["using", "regular", "method", "calculateordertotal", "order"], "sentSegmentedWithoutStopsStemmed": ["use", "regular", "method", "calculateordertot", "order"]}, {"number": 4938, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "However, using a regular method means that the data is recomputed with every render.", "sentSegmented": ["however", "using", "a", "regular", "method", "means", "that", "the", "data", "is", "recomputed", "with", "every", "render"], "sentSegmentedWithoutStops": ["however", "using", "regular", "method", "means", "data", "recomputed", "every", "render"], "sentSegmentedWithoutStopsStemmed": ["howev", "use", "regular", "method", "mean", "data", "recomput", "everi", "render"]}, {"number": 4939, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "That's bad for performance.", "sentSegmented": ["that", "'s", "bad", "for", "performance"], "sentSegmentedWithoutStops": ["'s", "bad", "performance"], "sentSegmentedWithoutStopsStemmed": ["'s", "bad", "perform"]}, {"number": 4940, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Create a separate functional component for the list item, and create an instance of that component for each item in the list, such as .", "sentSegmented": ["create", "a", "separate", "functional", "component", "for", "the", "list", "item", "and", "create", "an", "instance", "of", "that", "component", "for", "each", "item", "in", "the", "list", "such", "as"], "sentSegmentedWithoutStops": ["create", "separate", "functional", "component", "list", "item", "create", "instance", "component", "item", "list"], "sentSegmentedWithoutStopsStemmed": ["creat", "separ", "function", "compon", "list", "item", "creat", "instanc", "compon", "item", "list"]}, {"number": 4941, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "The component will then only re-render when the data passed to it is changed, which is what we want.", "sentSegmented": ["the", "component", "will", "then", "only", "re-render", "when", "the", "data", "passed", "to", "it", "is", "changed", "which", "is", "what", "we", "want"], "sentSegmentedWithoutStops": ["component", "re-render", "data", "passed", "changed", "want"], "sentSegmentedWithoutStopsStemmed": ["compon", "re-rend", "data", "pass", "chang", "want"]}, {"number": 4942, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "However, putting the template in the component is not ideal because a) these are usually small snippets that don't really warrant being in their own template b) if the component uses a template then it needs its own .vue file, which makes this solution feel even heavier than it already is.", "sentSegmented": ["however", "putting", "the", "template", "in", "the", "component", "is", "not", "ideal", "because", "a", "these", "are", "usually", "small", "snippets", "that", "do", "n't", "really", "warrant", "being", "in", "their", "own", "template", "b", "if", "the", "component", "uses", "a", "template", "then", "it", "needs", "its", "own", ".vue", "file", "which", "makes", "this", "solution", "feel", "even", "heavier", "than", "it", "already", "is"], "sentSegmentedWithoutStops": ["however", "putting", "template", "component", "ideal", "usually", "small", "snippets", "n't", "really", "warrant", "template", "b", "component", "uses", "template", "needs", ".vue", "file", "makes", "solution", "feel", "even", "heavier", "already"], "sentSegmentedWithoutStopsStemmed": ["howev", "put", "templat", "compon", "ideal", "usual", "small", "snippet", "n't", "realli", "warrant", "templat", "b", "compon", "use", "templat", "need", ".vue", "file", "make", "solut", "feel", "even", "heavier", "alreadi"]}, {"number": 4943, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "So the solution I came up with is to have the component only calculate the data, but render all of its HTML via the default slot, thereby forgoing the template altogether.", "sentSegmented": ["so", "the", "solution", "i", "came", "up", "with", "is", "to", "have", "the", "component", "only", "calculate", "the", "data", "but", "render", "all", "of", "its", "html", "via", "the", "default", "slot", "thereby", "forgoing", "the", "template", "altogether"], "sentSegmentedWithoutStops": ["solution", "came", "component", "calculate", "data", "render", "html", "via", "default", "slot", "thereby", "forgoing", "template", "altogether"], "sentSegmentedWithoutStopsStemmed": ["solut", "came", "compon", "calcul", "data", "render", "html", "via", "default", "slot", "therebi", "forgo", "templat", "altogeth"]}, {"number": 4944, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "And now we get to the crux of the issue: if we pass content in the slot to the child component, it will always re-render along with the parent, which means that the data will also be recalculated on every single render1.", "sentSegmented": ["and", "now", "we", "get", "to", "the", "crux", "of", "the", "issue", "if", "we", "pass", "content", "in", "the", "slot", "to", "the", "child", "component", "it", "will", "always", "re-render", "along", "with", "the", "parent", "which", "means", "that", "the", "data", "will", "also", "be", "recalculated", "on", "every", "single", "render1"], "sentSegmentedWithoutStops": ["get", "crux", "issue", "pass", "content", "slot", "child", "component", "always", "re-render", "along", "parent", "means", "data", "also", "recalculated", "every", "single", "render1"], "sentSegmentedWithoutStopsStemmed": ["get", "crux", "issu", "pass", "content", "slot", "child", "compon", "alway", "re-rend", "along", "parent", "mean", "data", "also", "recalcul", "everi", "singl", "render1"]}, {"number": 4945, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "This totally negates any benefit we got over using a regular method.", "sentSegmented": ["this", "totally", "negates", "any", "benefit", "we", "got", "over", "using", "a", "regular", "method"], "sentSegmentedWithoutStops": ["totally", "negates", "benefit", "got", "using", "regular", "method"], "sentSegmentedWithoutStopsStemmed": ["total", "negat", "benefit", "got", "use", "regular", "method"]}, {"number": 4946, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Here's demo in action: https://codepen.io/JosephSilber/pen/MXJZro", "sentSegmented": ["here", "'s", "demo", "in", "action", "https", "//codepen.io/josephsilber/pen/mxjzro"], "sentSegmentedWithoutStops": ["'s", "demo", "action", "https", "//codepen.io/josephsilber/pen/mxjzro"], "sentSegmentedWithoutStopsStemmed": ["'s", "demo", "action", "http", "//codepen.io/josephsilber/pen/mxjzro"]}, {"number": 4947, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "1 A potential solution would be to have a computed property within the child component, but then the component can no longer be functional.", "sentSegmented": ["1", "a", "potential", "solution", "would", "be", "to", "have", "a", "computed", "property", "within", "the", "child", "component", "but", "then", "the", "component", "can", "no", "longer", "be", "functional"], "sentSegmentedWithoutStops": ["1", "potential", "solution", "would", "computed", "property", "within", "child", "component", "component", "longer", "functional"], "sentSegmentedWithoutStopsStemmed": ["1", "potenti", "solut", "would", "comput", "properti", "within", "child", "compon", "compon", "longer", "function"]}, {"number": 4948, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "When rendering a big list, using functional components makes a huge difference.", "sentSegmented": ["when", "rendering", "a", "big", "list", "using", "functional", "components", "makes", "a", "huge", "difference"], "sentSegmentedWithoutStops": ["rendering", "big", "list", "using", "functional", "components", "makes", "huge", "difference"], "sentSegmentedWithoutStopsStemmed": ["render", "big", "list", "use", "function", "compon", "make", "huge", "differ"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDM5Nzg3NzEwNg==", "author": {"login": "jacekkarczmarczyk"}, "body": "You can create a computed prop that returns an array of total order values for all orders", "bodyText": "You can create a computed prop that returns an array of total order values for all orders", "bodyHTML": "<p>You can create a computed prop that returns an array of total order values for all orders</p>", "createdAt": "2018-06-17T12:54:16Z", "publishedAt": "2018-06-17T12:54:16Z", "lastEditedAt": "2018-06-17T12:54:32Z", "updatedAt": "2018-06-17T12:54:32Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 4949, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "You can create a computed prop that returns an array of total order values for all orders", "sentSegmented": ["you", "can", "create", "a", "computed", "prop", "that", "returns", "an", "array", "of", "total", "order", "values", "for", "all", "orders"], "sentSegmentedWithoutStops": ["create", "computed", "prop", "returns", "array", "total", "order", "values", "orders"], "sentSegmentedWithoutStopsStemmed": ["creat", "comput", "prop", "return", "array", "total", "order", "valu", "order"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDM5NzkxOTE3OQ==", "author": {"login": "JosephSilber"}, "body": "@jacekkarczmarczyk the problem with that is that if _any_ of the orders changes, _all_ order totals then have to be recalculated.", "bodyText": "@jacekkarczmarczyk the problem with that is that if any of the orders changes, all order totals then have to be recalculated.", "bodyHTML": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/jacekkarczmarczyk/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/jacekkarczmarczyk\">@jacekkarczmarczyk</a> the problem with that is that if <em>any</em> of the orders changes, <em>all</em> order totals then have to be recalculated.</p>", "createdAt": "2018-06-18T01:01:42Z", "publishedAt": "2018-06-18T01:01:42Z", "lastEditedAt": null, "updatedAt": "2018-06-18T01:01:42Z", "reactions": {"edges": [{"node": {"content": "THUMBS_UP", "createdAt": "2020-07-21T12:51:02Z"}}]}, "bodyParsed": [{"number": 4950, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "@jacekkarczmarczyk the problem with that is that if any of the orders changes, all order totals then have to be recalculated.", "sentSegmented": ["jacekkarczmarczyk", "the", "problem", "with", "that", "is", "that", "if", "any", "of", "the", "orders", "changes", "all", "order", "totals", "then", "have", "to", "be", "recalculated"], "sentSegmentedWithoutStops": ["jacekkarczmarczyk", "problem", "orders", "changes", "order", "totals", "recalculated"], "sentSegmentedWithoutStopsStemmed": ["jacekkarczmarczyk", "problem", "order", "chang", "order", "total", "recalcul"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDQyNTcyNTc2NA==", "author": {"login": "JosephSilber"}, "body": "Good news! It seems like this will be resolved in Vue 3.0:\r\n\r\n> All compiler-generated slots are now functions and invoked during the child component\u2019s render call. This ensures dependencies in slots are collected as dependencies for the child instead of the parent.\r\n>\r\n> This means that:\r\n>\r\n> 1. when slot content changes, only the child re-renders;\r\n> 2. when the parent re-renders, the child does not have to if its slot content did not change.\r\n\r\nhttps://medium.com/the-vue-point/plans-for-the-next-iteration-of-vue-js-777ffea6fabf", "bodyText": "Good news! It seems like this will be resolved in Vue 3.0:\n\nAll compiler-generated slots are now functions and invoked during the child component\u2019s render call. This ensures dependencies in slots are collected as dependencies for the child instead of the parent.\nThis means that:\n\nwhen slot content changes, only the child re-renders;\nwhen the parent re-renders, the child does not have to if its slot content did not change.\n\n\nhttps://medium.com/the-vue-point/plans-for-the-next-iteration-of-vue-js-777ffea6fabf", "bodyHTML": "<p>Good news! It seems like this will be resolved in Vue 3.0:</p>\n<blockquote>\n<p>All compiler-generated slots are now functions and invoked during the child component\u2019s render call. This ensures dependencies in slots are collected as dependencies for the child instead of the parent.</p>\n<p>This means that:</p>\n<ol>\n<li>when slot content changes, only the child re-renders;</li>\n<li>when the parent re-renders, the child does not have to if its slot content did not change.</li>\n</ol>\n</blockquote>\n<p><a rel=\"nofollow\" href=\"https://medium.com/the-vue-point/plans-for-the-next-iteration-of-vue-js-777ffea6fabf\">https://medium.com/the-vue-point/plans-for-the-next-iteration-of-vue-js-777ffea6fabf</a></p>", "createdAt": "2018-09-30T14:44:10Z", "publishedAt": "2018-09-30T14:44:10Z", "lastEditedAt": "2018-09-30T14:46:38Z", "updatedAt": "2018-09-30T14:46:38Z", "reactions": {"edges": [{"node": {"content": "THUMBS_UP", "createdAt": "2018-11-21T12:35:24Z"}}, {"node": {"content": "THUMBS_UP", "createdAt": "2019-04-08T09:58:24Z"}}, {"node": {"content": "THUMBS_UP", "createdAt": "2019-10-15T13:10:54Z"}}, {"node": {"content": "THUMBS_UP", "createdAt": "2020-04-20T14:59:22Z"}}]}, "bodyParsed": [{"number": 4951, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Good news!", "sentSegmented": ["good", "news"], "sentSegmentedWithoutStops": ["good", "news"], "sentSegmentedWithoutStopsStemmed": ["good", "news"]}, {"number": 4952, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "It seems like this will be resolved in Vue 3.0:", "sentSegmented": ["it", "seems", "like", "this", "will", "be", "resolved", "in", "vue", "3.0"], "sentSegmentedWithoutStops": ["seems", "like", "resolved", "vue", "3.0"], "sentSegmentedWithoutStopsStemmed": ["seem", "like", "resolv", "vue", "3.0"]}, {"number": 4953, "isCode": false, "isBlockQuote": true, "blockQuoteDepth": 1, "sent": "All compiler-generated slots are now functions and invoked during the child component\u2019s render call.", "sentSegmented": ["all", "compiler-generated", "slots", "are", "now", "functions", "and", "invoked", "during", "the", "child", "component", "s", "render", "call"], "sentSegmentedWithoutStops": ["compiler-generated", "slots", "functions", "invoked", "child", "component", "render", "call"], "sentSegmentedWithoutStopsStemmed": ["compiler-gener", "slot", "function", "invok", "child", "compon", "render", "call"]}, {"number": 4954, "isCode": false, "isBlockQuote": true, "blockQuoteDepth": 1, "sent": "This ensures dependencies in slots are collected as dependencies for the child instead of the parent.", "sentSegmented": ["this", "ensures", "dependencies", "in", "slots", "are", "collected", "as", "dependencies", "for", "the", "child", "instead", "of", "the", "parent"], "sentSegmentedWithoutStops": ["ensures", "dependencies", "slots", "collected", "dependencies", "child", "instead", "parent"], "sentSegmentedWithoutStopsStemmed": ["ensur", "depend", "slot", "collect", "depend", "child", "instead", "parent"]}, {"number": 4955, "isCode": false, "isBlockQuote": true, "blockQuoteDepth": 1, "sent": "This means that:", "sentSegmented": ["this", "means", "that"], "sentSegmentedWithoutStops": ["means"], "sentSegmentedWithoutStopsStemmed": ["mean"]}, {"number": 4956, "isCode": false, "isBlockQuote": true, "blockQuoteDepth": 1, "sent": "when slot content changes, only the child re-renders;", "sentSegmented": ["when", "slot", "content", "changes", "only", "the", "child", "re-renders"], "sentSegmentedWithoutStops": ["slot", "content", "changes", "child", "re-renders"], "sentSegmentedWithoutStopsStemmed": ["slot", "content", "chang", "child", "re-rend"]}, {"number": 4957, "isCode": false, "isBlockQuote": true, "blockQuoteDepth": 1, "sent": "when the parent re-renders, the child does not have to if its slot content did not change.", "sentSegmented": ["when", "the", "parent", "re-renders", "the", "child", "does", "not", "have", "to", "if", "its", "slot", "content", "did", "not", "change"], "sentSegmentedWithoutStops": ["parent", "re-renders", "child", "slot", "content", "change"], "sentSegmentedWithoutStopsStemmed": ["parent", "re-rend", "child", "slot", "content", "chang"]}, {"number": 4958, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "https://medium.com/the-vue-point/plans-for-the-next-iteration-of-vue-js-777ffea6fabf", "sentSegmented": ["https", "//medium.com/the-vue-point/plans-for-the-next-iteration-of-vue-js-777ffea6fabf"], "sentSegmentedWithoutStops": ["https", "//medium.com/the-vue-point/plans-for-the-next-iteration-of-vue-js-777ffea6fabf"], "sentSegmentedWithoutStopsStemmed": ["http", "//medium.com/the-vue-point/plans-for-the-next-iteration-of-vue-js-777ffea6fabf"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDQ1MzYzMzA0NA==", "author": {"login": "steve-heine"}, "body": "will there be a 2.6 update to fix this?\r\n\r\nI have a basic spreadsheet like app where some slots are overridden with slots representing validation or special formatting of the data. When a user updates a the model within an input and tabs to the next input, the components child slots re-render causing the parent to re-render, and the user's input box loses its focus.", "bodyText": "will there be a 2.6 update to fix this?\nI have a basic spreadsheet like app where some slots are overridden with slots representing validation or special formatting of the data. When a user updates a the model within an input and tabs to the next input, the components child slots re-render causing the parent to re-render, and the user's input box loses its focus.", "bodyHTML": "<p>will there be a 2.6 update to fix this?</p>\n<p>I have a basic spreadsheet like app where some slots are overridden with slots representing validation or special formatting of the data. When a user updates a the model within an input and tabs to the next input, the components child slots re-render causing the parent to re-render, and the user's input box loses its focus.</p>", "createdAt": "2019-01-11T19:37:06Z", "publishedAt": "2019-01-11T19:37:06Z", "lastEditedAt": null, "updatedAt": "2019-01-11T19:37:06Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 4959, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "will there be a 2.6 update to fix this?", "sentSegmented": ["will", "there", "be", "a", "2.6", "update", "to", "fix", "this"], "sentSegmentedWithoutStops": ["2.6", "update", "fix"], "sentSegmentedWithoutStopsStemmed": ["2.6", "updat", "fix"]}, {"number": 4960, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "I have a basic spreadsheet like app where some slots are overridden with slots representing validation or special formatting of the data.", "sentSegmented": ["i", "have", "a", "basic", "spreadsheet", "like", "app", "where", "some", "slots", "are", "overridden", "with", "slots", "representing", "validation", "or", "special", "formatting", "of", "the", "data"], "sentSegmentedWithoutStops": ["basic", "spreadsheet", "like", "app", "slots", "overridden", "slots", "representing", "validation", "special", "formatting", "data"], "sentSegmentedWithoutStopsStemmed": ["basic", "spreadsheet", "like", "app", "slot", "overridden", "slot", "repres", "valid", "special", "format", "data"]}, {"number": 4961, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "When a user updates a the model within an input and tabs to the next input, the components child slots re-render causing the parent to re-render, and the user's input box loses its focus.", "sentSegmented": ["when", "a", "user", "updates", "a", "the", "model", "within", "an", "input", "and", "tabs", "to", "the", "next", "input", "the", "components", "child", "slots", "re-render", "causing", "the", "parent", "to", "re-render", "and", "the", "user", "'s", "input", "box", "loses", "its", "focus"], "sentSegmentedWithoutStops": ["user", "updates", "model", "within", "input", "tabs", "next", "input", "components", "child", "slots", "re-render", "causing", "parent", "re-render", "user", "'s", "input", "box", "loses", "focus"], "sentSegmentedWithoutStopsStemmed": ["user", "updat", "model", "within", "input", "tab", "next", "input", "compon", "child", "slot", "re-rend", "caus", "parent", "re-rend", "user", "'s", "input", "box", "lose", "focu"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDQ1NzYyMzQ4MQ==", "author": {"login": "stygmate"}, "body": "Any news on this ? it make some code/lib (using a lot slots) unusable.\r\nIn my case it make Vuetify very performance hungry as a lot of thing rerender without need.", "bodyText": "Any news on this ? it make some code/lib (using a lot slots) unusable.\nIn my case it make Vuetify very performance hungry as a lot of thing rerender without need.", "bodyHTML": "<p>Any news on this ? it make some code/lib (using a lot slots) unusable.<br>\nIn my case it make Vuetify very performance hungry as a lot of thing rerender without need.</p>", "createdAt": "2019-01-25T16:07:38Z", "publishedAt": "2019-01-25T16:07:38Z", "lastEditedAt": null, "updatedAt": "2019-01-25T16:07:38Z", "reactions": {"edges": [{"node": {"content": "THUMBS_UP", "createdAt": "2019-01-25T19:51:07Z"}}, {"node": {"content": "THUMBS_UP", "createdAt": "2019-01-28T11:53:22Z"}}, {"node": {"content": "THUMBS_UP", "createdAt": "2019-03-22T16:08:24Z"}}, {"node": {"content": "THUMBS_UP", "createdAt": "2019-07-11T06:15:16Z"}}, {"node": {"content": "THUMBS_UP", "createdAt": "2020-12-09T08:06:39Z"}}]}, "bodyParsed": [{"number": 4962, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Any news on this ?", "sentSegmented": ["any", "news", "on", "this"], "sentSegmentedWithoutStops": ["news"], "sentSegmentedWithoutStopsStemmed": ["news"]}, {"number": 4963, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "it make some code/lib (using a lot slots) unusable.", "sentSegmented": ["it", "make", "some", "code/lib", "using", "a", "lot", "slots", "unusable"], "sentSegmentedWithoutStops": ["make", "code/lib", "using", "lot", "slots", "unusable"], "sentSegmentedWithoutStopsStemmed": ["make", "code/lib", "use", "lot", "slot", "unus"]}, {"number": 4964, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "In my case it make Vuetify very performance hungry as a lot of thing rerender without need.", "sentSegmented": ["in", "my", "case", "it", "make", "vuetify", "very", "performance", "hungry", "as", "a", "lot", "of", "thing", "rerender", "without", "need"], "sentSegmentedWithoutStops": ["case", "make", "vuetify", "performance", "hungry", "lot", "thing", "rerender", "without", "need"], "sentSegmentedWithoutStopsStemmed": ["case", "make", "vuetifi", "perform", "hungri", "lot", "thing", "rerend", "without", "need"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDQ1Nzg4MjE2NA==", "author": {"login": "JosephSilber"}, "body": "@stygmate the just-released [v2.6.0-beta.2](https://github.com/vuejs/vue/releases/tag/v2.6.0-beta.2) includes #9371, which addresses this issue.", "bodyText": "@stygmate the just-released v2.6.0-beta.2 includes #9371, which addresses this issue.", "bodyHTML": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/stygmate/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/stygmate\">@stygmate</a> the just-released <a href=\"https://github.com/vuejs/vue/releases/tag/v2.6.0-beta.2\">v2.6.0-beta.2</a> includes <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"403313440\" data-permission-text=\"Title is private\" data-url=\"https://github.com/vuejs/vue/issues/9371\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/vuejs/vue/pull/9371/hovercard\" href=\"https://github.com/vuejs/vue/pull/9371\">#9371</a>, which addresses this issue.</p>", "createdAt": "2019-01-27T01:58:54Z", "publishedAt": "2019-01-27T01:58:54Z", "lastEditedAt": null, "updatedAt": "2019-01-27T01:58:54Z", "reactions": {"edges": [{"node": {"content": "THUMBS_UP", "createdAt": "2019-01-28T11:53:19Z"}}, {"node": {"content": "THUMBS_UP", "createdAt": "2019-01-29T16:10:59Z"}}]}, "bodyParsed": [{"number": 4965, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "@stygmate the just-released v2.6.0-beta.2 includes #9371, which addresses this issue.", "sentSegmented": ["stygmate", "the", "just-released", "v2.6.0-beta.2", "includes", "9371", "which", "addresses", "this", "issue"], "sentSegmentedWithoutStops": ["stygmate", "just-released", "v2.6.0-beta.2", "includes", "9371", "addresses", "issue"], "sentSegmentedWithoutStopsStemmed": ["stygmat", "just-releas", "v2.6.0-beta.2", "includ", "9371", "address", "issu"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDQ2NzA1MDQ0MQ==", "author": {"login": "jlsjonas"}, "body": "@JosephSilber That doesn't seem to address dynamically created slots, right?\r\n\r\nWe have a lot of forms where the structures are defined by a json document on load, this does mean that the slots are dynamically defined (even if they don't change once loaded in)\r\n\r\nA big issue the rerender is causing is that certain sub-components fetch extra data, which it's doing on every re-render in this case.\r\nIf anyone can provide a viable workaround that would be great too \ud83d\udc4d ", "bodyText": "@JosephSilber That doesn't seem to address dynamically created slots, right?\nWe have a lot of forms where the structures are defined by a json document on load, this does mean that the slots are dynamically defined (even if they don't change once loaded in)\nA big issue the rerender is causing is that certain sub-components fetch extra data, which it's doing on every re-render in this case.\nIf anyone can provide a viable workaround that would be great too \ud83d\udc4d", "bodyHTML": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/JosephSilber/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/JosephSilber\">@JosephSilber</a> That doesn't seem to address dynamically created slots, right?</p>\n<p>We have a lot of forms where the structures are defined by a json document on load, this does mean that the slots are dynamically defined (even if they don't change once loaded in)</p>\n<p>A big issue the rerender is causing is that certain sub-components fetch extra data, which it's doing on every re-render in this case.<br>\nIf anyone can provide a viable workaround that would be great too <g-emoji class=\"g-emoji\" alias=\"+1\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png\">\ud83d\udc4d</g-emoji></p>", "createdAt": "2019-02-25T15:18:19Z", "publishedAt": "2019-02-25T15:18:19Z", "lastEditedAt": "2019-02-25T15:19:50Z", "updatedAt": "2019-02-25T15:19:50Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 4966, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "@JosephSilber That doesn't seem to address dynamically created slots, right?", "sentSegmented": ["josephsilber", "that", "does", "n't", "seem", "to", "address", "dynamically", "created", "slots", "right"], "sentSegmentedWithoutStops": ["josephsilber", "n't", "seem", "address", "dynamically", "created", "slots", "right"], "sentSegmentedWithoutStopsStemmed": ["josephsilb", "n't", "seem", "address", "dynam", "creat", "slot", "right"]}, {"number": 4967, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "We have a lot of forms where the structures are defined by a json document on load, this does mean that the slots are dynamically defined (even if they don't change once loaded in)", "sentSegmented": ["we", "have", "a", "lot", "of", "forms", "where", "the", "structures", "are", "defined", "by", "a", "json", "document", "on", "load", "this", "does", "mean", "that", "the", "slots", "are", "dynamically", "defined", "even", "if", "they", "do", "n't", "change", "once", "loaded", "in"], "sentSegmentedWithoutStops": ["lot", "forms", "structures", "defined", "json", "document", "load", "mean", "slots", "dynamically", "defined", "even", "n't", "change", "loaded"], "sentSegmentedWithoutStopsStemmed": ["lot", "form", "structur", "defin", "json", "document", "load", "mean", "slot", "dynam", "defin", "even", "n't", "chang", "load"]}, {"number": 4968, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "A big issue the rerender is causing is that certain sub-components fetch extra data, which it's doing on every re-render in this case.", "sentSegmented": ["a", "big", "issue", "the", "rerender", "is", "causing", "is", "that", "certain", "sub-components", "fetch", "extra", "data", "which", "it", "'s", "doing", "on", "every", "re-render", "in", "this", "case"], "sentSegmentedWithoutStops": ["big", "issue", "rerender", "causing", "certain", "sub-components", "fetch", "extra", "data", "'s", "every", "re-render", "case"], "sentSegmentedWithoutStopsStemmed": ["big", "issu", "rerend", "caus", "certain", "sub-compon", "fetch", "extra", "data", "'s", "everi", "re-rend", "case"]}, {"number": 4969, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "If anyone can provide a viable workaround that would be great too \ud83d\udc4d", "sentSegmented": ["if", "anyone", "can", "provide", "a", "viable", "workaround", "that", "would", "be", "great", "too"], "sentSegmentedWithoutStops": ["anyone", "provide", "viable", "workaround", "would", "great"], "sentSegmentedWithoutStopsStemmed": ["anyon", "provid", "viabl", "workaround", "would", "great"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDQ2NzA1MzIyOQ==", "author": {"login": "LinusBorg"}, "body": "> We have a lot of forms where the structures are defined by a json document on load, this does mean that the slots are dynamically defined (even if they don't change once loaded in)\r\n\r\nThis short explanation doesn't really explain what exactly you do and mean by \"dynamically created slots\".\r\n\r\nI would advise you to join us in the forums @ forum.vuejs.org and open a more in-depth topic explaining your situation there.", "bodyText": "We have a lot of forms where the structures are defined by a json document on load, this does mean that the slots are dynamically defined (even if they don't change once loaded in)\n\nThis short explanation doesn't really explain what exactly you do and mean by \"dynamically created slots\".\nI would advise you to join us in the forums @ forum.vuejs.org and open a more in-depth topic explaining your situation there.", "bodyHTML": "<blockquote>\n<p>We have a lot of forms where the structures are defined by a json document on load, this does mean that the slots are dynamically defined (even if they don't change once loaded in)</p>\n</blockquote>\n<p>This short explanation doesn't really explain what exactly you do and mean by \"dynamically created slots\".</p>\n<p>I would advise you to join us in the forums @ forum.vuejs.org and open a more in-depth topic explaining your situation there.</p>", "createdAt": "2019-02-25T15:25:42Z", "publishedAt": "2019-02-25T15:25:42Z", "lastEditedAt": null, "updatedAt": "2019-02-25T15:25:42Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 4970, "isCode": false, "isBlockQuote": true, "blockQuoteDepth": 1, "sent": "We have a lot of forms where the structures are defined by a json document on load, this does mean that the slots are dynamically defined (even if they don't change once loaded in)", "sentSegmented": ["we", "have", "a", "lot", "of", "forms", "where", "the", "structures", "are", "defined", "by", "a", "json", "document", "on", "load", "this", "does", "mean", "that", "the", "slots", "are", "dynamically", "defined", "even", "if", "they", "do", "n't", "change", "once", "loaded", "in"], "sentSegmentedWithoutStops": ["lot", "forms", "structures", "defined", "json", "document", "load", "mean", "slots", "dynamically", "defined", "even", "n't", "change", "loaded"], "sentSegmentedWithoutStopsStemmed": ["lot", "form", "structur", "defin", "json", "document", "load", "mean", "slot", "dynam", "defin", "even", "n't", "chang", "load"]}, {"number": 4971, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "This short explanation doesn't really explain what exactly you do and mean by \"dynamically created slots\".", "sentSegmented": ["this", "short", "explanation", "does", "n't", "really", "explain", "what", "exactly", "you", "do", "and", "mean", "by", "dynamically", "created", "slots"], "sentSegmentedWithoutStops": ["short", "explanation", "n't", "really", "explain", "exactly", "mean", "dynamically", "created", "slots"], "sentSegmentedWithoutStopsStemmed": ["short", "explan", "n't", "realli", "explain", "exactli", "mean", "dynam", "creat", "slot"]}, {"number": 4972, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "I would advise you to join us in the forums @ forum.vuejs.org and open a more in-depth topic explaining your situation there.", "sentSegmented": ["i", "would", "advise", "you", "to", "join", "us", "in", "the", "forums", "forum.vuejs.org", "and", "open", "a", "more", "in-depth", "topic", "explaining", "your", "situation", "there"], "sentSegmentedWithoutStops": ["would", "advise", "join", "us", "forums", "forum.vuejs.org", "open", "in-depth", "topic", "explaining", "situation"], "sentSegmentedWithoutStopsStemmed": ["would", "advis", "join", "us", "forum", "forum.vuejs.org", "open", "in-depth", "topic", "explain", "situat"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDQ2NzA2MDU5NA==", "author": {"login": "jlsjonas"}, "body": "A `.json` fetched from the server (see [docs](https://docs.laravel-enso.com/packages/form-builder.html#usage) for format example)\r\n\r\nall `\"custom\": true,` fields are translated to a slot in [EnsoForm.vue](https://github.com/laravel-enso/FormBuilder/blob/master/src/resources/js/components/enso/vueforms/EnsoForm.vue) which are then filled by the page implementing the form.\r\n\r\nA simple example is a custom multi-select where a sum is added\r\n\r\n```vue\r\n<template slot=\"example\" slot-scope=\"{ field, errors, i18n, locale }\">\r\n    <div>\r\n        <select-field\r\n            :errors=\"errors\"\r\n            :field=\"field\"\r\n            :i18n=\"i18n\"\r\n            :locale=\"locale\"\r\n            ref=\"example\"\r\n            :custom-params=\"{ repairType: lastParent.id || null }\"\r\n            @input=\"serviceSelected\"\r\n        />\r\n        <span>Total: {{ total }}</span>\r\n    </div>\r\n</template>\r\n```\r\n\r\nCurrently, when the total is updated the whole form is re-rendered, which causes all ([server-side](https://docs.laravel-enso.com/packages/form-builder.html#server-side-select)) `<select-field>` components to fetch their options from the server again", "bodyText": "A .json fetched from the server (see docs for format example)\nall \"custom\": true, fields are translated to a slot in EnsoForm.vue which are then filled by the page implementing the form.\nA simple example is a custom multi-select where a sum is added\n<template slot=\"example\" slot-scope=\"{ field, errors, i18n, locale }\">\n    <div>\n        <select-field\n            :errors=\"errors\"\n            :field=\"field\"\n            :i18n=\"i18n\"\n            :locale=\"locale\"\n            ref=\"example\"\n            :custom-params=\"{ repairType: lastParent.id || null }\"\n            @input=\"serviceSelected\"\n        />\n        <span>Total: {{ total }}</span>\n    </div>\n</template>\nCurrently, when the total is updated the whole form is re-rendered, which causes all (server-side) <select-field> components to fetch their options from the server again", "bodyHTML": "<p>A <code>.json</code> fetched from the server (see <a href=\"https://docs.laravel-enso.com/packages/form-builder.html#usage\" rel=\"nofollow\">docs</a> for format example)</p>\n<p>all <code>\"custom\": true,</code> fields are translated to a slot in <a href=\"https://github.com/laravel-enso/FormBuilder/blob/master/src/resources/js/components/enso/vueforms/EnsoForm.vue\">EnsoForm.vue</a> which are then filled by the page implementing the form.</p>\n<p>A simple example is a custom multi-select where a sum is added</p>\n<div class=\"highlight highlight-text-html-vue\"><pre>&lt;<span class=\"pl-ent\">template</span> <span class=\"pl-e\">slot</span>=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>example<span class=\"pl-pds\">\"</span></span> <span class=\"pl-e\">slot-scope</span>=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>{ field, errors, i18n, locale }<span class=\"pl-pds\">\"</span></span>&gt;\n    &lt;<span class=\"pl-ent\">div</span>&gt;\n        &lt;<span class=\"pl-ent\">select</span><span class=\"pl-e\">-field</span>\n            :<span class=\"pl-e\">errors</span>=<span class=\"pl-s1\"><span class=\"pl-pds\">\"</span>errors<span class=\"pl-pds\">\"</span></span>\n            :<span class=\"pl-e\">field</span>=<span class=\"pl-s1\"><span class=\"pl-pds\">\"</span>field<span class=\"pl-pds\">\"</span></span>\n            :<span class=\"pl-e\">i</span>18n=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>i18n<span class=\"pl-pds\">\"</span></span>\n            :<span class=\"pl-e\">locale</span>=<span class=\"pl-s1\"><span class=\"pl-pds\">\"</span>locale<span class=\"pl-pds\">\"</span></span>\n            <span class=\"pl-e\">ref</span>=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>example<span class=\"pl-pds\">\"</span></span>\n            :<span class=\"pl-e\">custom-params</span>=<span class=\"pl-s1\"><span class=\"pl-pds\">\"</span>{ repairType<span class=\"pl-k\">:</span> <span class=\"pl-smi\">lastParent</span>.<span class=\"pl-c1\">id</span> <span class=\"pl-k\">||</span> <span class=\"pl-c1\">null</span> }<span class=\"pl-pds\">\"</span></span>\n            @<span class=\"pl-e\">input</span>=<span class=\"pl-s1\"><span class=\"pl-pds\">\"</span>serviceSelected<span class=\"pl-pds\">\"</span></span>\n        /&gt;\n        &lt;<span class=\"pl-ent\">span</span>&gt;Total: {{ total }}&lt;/<span class=\"pl-ent\">span</span>&gt;\n    &lt;/<span class=\"pl-ent\">div</span>&gt;\n&lt;/<span class=\"pl-ent\">template</span>&gt;</pre></div>\n<p>Currently, when the total is updated the whole form is re-rendered, which causes all (<a href=\"https://docs.laravel-enso.com/packages/form-builder.html#server-side-select\" rel=\"nofollow\">server-side</a>) <code>&lt;select-field&gt;</code> components to fetch their options from the server again</p>", "createdAt": "2019-02-25T15:43:46Z", "publishedAt": "2019-02-25T15:43:46Z", "lastEditedAt": null, "updatedAt": "2019-02-25T15:43:46Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 4973, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "A .json fetched from the server (see docs for format example)", "sentSegmented": ["a", ".json", "fetched", "from", "the", "server", "see", "docs", "for", "format", "example"], "sentSegmentedWithoutStops": [".json", "fetched", "server", "see", "docs", "format", "example"], "sentSegmentedWithoutStopsStemmed": [".json", "fetch", "server", "see", "doc", "format", "exampl"]}, {"number": 4974, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "all \"custom\": true, fields are translated to a slot in EnsoForm.vue which are then filled by the page implementing the form.", "sentSegmented": ["all", "custom", "true", "fields", "are", "translated", "to", "a", "slot", "in", "ensoform.vue", "which", "are", "then", "filled", "by", "the", "page", "implementing", "the", "form"], "sentSegmentedWithoutStops": ["custom", "true", "fields", "translated", "slot", "ensoform.vue", "filled", "page", "implementing", "form"], "sentSegmentedWithoutStopsStemmed": ["custom", "true", "field", "translat", "slot", "ensoform.vu", "fill", "page", "implement", "form"]}, {"number": 4975, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "A simple example is a custom multi-select where a sum is added", "sentSegmented": ["a", "simple", "example", "is", "a", "custom", "multi-select", "where", "a", "sum", "is", "added"], "sentSegmentedWithoutStops": ["simple", "example", "custom", "multi-select", "sum", "added"], "sentSegmentedWithoutStopsStemmed": ["simpl", "exampl", "custom", "multi-select", "sum", "ad"]}, {"number": 4976, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "<template slot=\"example\" slot-scope=\"{ field, errors, i18n, locale }\">", "sentSegmented": ["template", "slot=", "example", "slot-scope=", "field", "errors", "i18n", "locale"], "sentSegmentedWithoutStops": ["slot=", "example", "slot-scope=", "field", "errors", "i18n", "locale"], "sentSegmentedWithoutStopsStemmed": ["slot=", "exampl", "slot-scope=", "field", "error", "i18n", "local"]}, {"number": 4977, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    <div>", "sentSegmented": ["div"], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4978, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        <select-field", "sentSegmented": ["select-field"], "sentSegmentedWithoutStops": ["select-field"], "sentSegmentedWithoutStopsStemmed": ["select-field"]}, {"number": 4979, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "            :errors=\"errors\"", "sentSegmented": ["errors=", "errors"], "sentSegmentedWithoutStops": ["errors=", "errors"], "sentSegmentedWithoutStopsStemmed": ["errors=", "error"]}, {"number": 4980, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "            :field=\"field\"", "sentSegmented": ["field=", "field"], "sentSegmentedWithoutStops": ["field=", "field"], "sentSegmentedWithoutStopsStemmed": ["field=", "field"]}, {"number": 4981, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "            :i18n=\"i18n\"", "sentSegmented": ["i18n=", "i18n"], "sentSegmentedWithoutStops": ["i18n=", "i18n"], "sentSegmentedWithoutStopsStemmed": ["i18n=", "i18n"]}, {"number": 4982, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "            :locale=\"locale\"", "sentSegmented": ["locale=", "locale"], "sentSegmentedWithoutStops": ["locale=", "locale"], "sentSegmentedWithoutStopsStemmed": ["locale=", "local"]}, {"number": 4983, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "            ref=\"example\"", "sentSegmented": ["ref=", "example"], "sentSegmentedWithoutStops": ["ref=", "example"], "sentSegmentedWithoutStopsStemmed": ["ref=", "exampl"]}, {"number": 4984, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "            :custom-params=\"{ repairType: lastParent.id || null }\"", "sentSegmented": ["custom-params=", "repairtype", "lastparent.id", "null"], "sentSegmentedWithoutStops": ["custom-params=", "repairtype", "lastparent.id"], "sentSegmentedWithoutStopsStemmed": ["custom-params=", "repairtyp", "lastparent.id"]}, {"number": 4985, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "            @input=\"serviceSelected\"", "sentSegmented": ["input=", "serviceselected"], "sentSegmentedWithoutStops": ["input=", "serviceselected"], "sentSegmentedWithoutStopsStemmed": ["input=", "serviceselect"]}, {"number": 4986, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        />", "sentSegmented": [], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4987, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "        <span>Total: {{ total }}span>", "sentSegmented": ["span", "total", "total", "span"], "sentSegmentedWithoutStops": ["total", "total"], "sentSegmentedWithoutStopsStemmed": ["total", "total"]}, {"number": 4988, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    div>", "sentSegmented": ["div"], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4989, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "template>", "sentSegmented": ["template"], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 4990, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Currently, when the total is updated the whole form is re-rendered, which causes all (server-side)  components to fetch their options from the server again", "sentSegmented": ["currently", "when", "the", "total", "is", "updated", "the", "whole", "form", "is", "re-rendered", "which", "causes", "all", "server-side", "components", "to", "fetch", "their", "options", "from", "the", "server", "again"], "sentSegmentedWithoutStops": ["currently", "total", "updated", "whole", "form", "re-rendered", "causes", "server-side", "components", "fetch", "options", "server"], "sentSegmentedWithoutStopsStemmed": ["current", "total", "updat", "whole", "form", "re-rend", "caus", "server-sid", "compon", "fetch", "option", "server"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDQ4NTIzMjI0OA==", "author": {"login": "stygmate"}, "body": "any news for this one ? Vuetify (the most stared Vuejs project) seems generate a lot of slot dynamically and performance are really really bad in some case. vuetifyjs/vuetify#6201", "bodyText": "any news for this one ? Vuetify (the most stared Vuejs project) seems generate a lot of slot dynamically and performance are really really bad in some case. vuetifyjs/vuetify#6201", "bodyHTML": "<p>any news for this one ? Vuetify (the most stared Vuejs project) seems generate a lot of slot dynamically and performance are really really bad in some case. <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"400815573\" data-permission-text=\"Title is private\" data-url=\"https://github.com/vuetifyjs/vuetify/issues/6201\" data-hovercard-type=\"issue\" data-hovercard-url=\"/vuetifyjs/vuetify/issues/6201/hovercard\" href=\"https://github.com/vuetifyjs/vuetify/issues/6201\">vuetifyjs/vuetify#6201</a></p>", "createdAt": "2019-04-21T07:45:05Z", "publishedAt": "2019-04-21T07:45:05Z", "lastEditedAt": null, "updatedAt": "2019-04-21T07:45:05Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 4991, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "any news for this one ?", "sentSegmented": ["any", "news", "for", "this", "one"], "sentSegmentedWithoutStops": ["news", "one"], "sentSegmentedWithoutStopsStemmed": ["news", "one"]}, {"number": 4992, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Vuetify (the most stared Vuejs project) seems generate a lot of slot dynamically and performance are really really bad in some case.", "sentSegmented": ["vuetify", "the", "most", "stared", "vuejs", "project", "seems", "generate", "a", "lot", "of", "slot", "dynamically", "and", "performance", "are", "really", "really", "bad", "in", "some", "case"], "sentSegmentedWithoutStops": ["vuetify", "stared", "vuejs", "project", "seems", "generate", "lot", "slot", "dynamically", "performance", "really", "really", "bad", "case"], "sentSegmentedWithoutStopsStemmed": ["vuetifi", "stare", "vuej", "project", "seem", "gener", "lot", "slot", "dynam", "perform", "realli", "realli", "bad", "case"]}, {"number": 4993, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "vuetifyjs/vuetify#6201", "sentSegmented": ["vuetifyjs/vuetify", "6201"], "sentSegmentedWithoutStops": ["vuetifyjs/vuetify", "6201"], "sentSegmentedWithoutStopsStemmed": ["vuetifyjs/vuetifi", "6201"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDQ4NTIzNDMwMQ==", "author": {"login": "LinusBorg"}, "body": "Would be helpful to have some. Up-to-date example that demonstrates the effect, especially with the new slot syntax. \r\n\r\nFrom what I've read I don't entirely get the problem. ", "bodyText": "Would be helpful to have some. Up-to-date example that demonstrates the effect, especially with the new slot syntax.\nFrom what I've read I don't entirely get the problem.", "bodyHTML": "<p>Would be helpful to have some. Up-to-date example that demonstrates the effect, especially with the new slot syntax.</p>\n<p>From what I've read I don't entirely get the problem.</p>", "createdAt": "2019-04-21T08:24:56Z", "publishedAt": "2019-04-21T08:24:56Z", "lastEditedAt": null, "updatedAt": "2019-04-21T08:24:56Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 4994, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Would be helpful to have some.", "sentSegmented": ["would", "be", "helpful", "to", "have", "some"], "sentSegmentedWithoutStops": ["would", "helpful"], "sentSegmentedWithoutStopsStemmed": ["would", "help"]}, {"number": 4995, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Up-to-date example that demonstrates the effect, especially with the new slot syntax.", "sentSegmented": ["up-to-date", "example", "that", "demonstrates", "the", "effect", "especially", "with", "the", "new", "slot", "syntax"], "sentSegmentedWithoutStops": ["up-to-date", "example", "demonstrates", "effect", "especially", "new", "slot", "syntax"], "sentSegmentedWithoutStopsStemmed": ["up-to-d", "exampl", "demonstr", "effect", "especi", "new", "slot", "syntax"]}, {"number": 4996, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "From what I've read I don't entirely get the problem.", "sentSegmented": ["from", "what", "i", "'ve", "read", "i", "do", "n't", "entirely", "get", "the", "problem"], "sentSegmentedWithoutStops": ["'ve", "read", "n't", "entirely", "get", "problem"], "sentSegmentedWithoutStopsStemmed": ["'ve", "read", "n't", "entir", "get", "problem"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDQ4NTI1OTc4NA==", "author": {"login": "wparad"}, "body": "@LinusBorg, it is really quite simple if you have an component with a slot\r\n```html\r\n<component>\r\n  <slot :value=\"value\" @change=\"v => value = v\" />\r\n</component>\r\n```\r\n\r\nWhenever the `@change` handler is fired `value` is updated. That is good. The problem is that when this value is updated vue rerenders the `slot`. That is exactly what you would want to happen and it does. The problem is that it does this by re-rendering the whole `component` not just the slot. You can test this out by putting anything else in the `component` and it get re-rendered too.\r\n\r\n```html\r\n<component>\r\n  <input />\r\n  <slot :value=\"value\" @change=\"v => value = v\" />\r\n</component>\r\n```\r\n\r\nSet the focus to the `input` field and when `value` changes, you'll the focus leave the `input`\r\n", "bodyText": "@LinusBorg, it is really quite simple if you have an component with a slot\n<component>\n  <slot :value=\"value\" @change=\"v => value = v\" />\n</component>\nWhenever the @change handler is fired value is updated. That is good. The problem is that when this value is updated vue rerenders the slot. That is exactly what you would want to happen and it does. The problem is that it does this by re-rendering the whole component not just the slot. You can test this out by putting anything else in the component and it get re-rendered too.\n<component>\n  <input />\n  <slot :value=\"value\" @change=\"v => value = v\" />\n</component>\nSet the focus to the input field and when value changes, you'll the focus leave the input", "bodyHTML": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/LinusBorg/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/LinusBorg\">@LinusBorg</a>, it is really quite simple if you have an component with a slot</p>\n<div class=\"highlight highlight-text-html-basic\"><pre><span class=\"pl-kos\">&lt;</span><span class=\"pl-ent\">component</span><span class=\"pl-kos\">&gt;</span>\n  <span class=\"pl-kos\">&lt;</span><span class=\"pl-ent\">slot</span> <span class=\"pl-c1\">:value</span>=\"<span class=\"pl-s\">value</span>\" <span class=\"pl-c1\">@change</span>=\"<span class=\"pl-s\">v =&gt; value = v</span>\" /&gt;\n<span class=\"pl-kos\">&lt;/</span><span class=\"pl-ent\">component</span><span class=\"pl-kos\">&gt;</span></pre></div>\n<p>Whenever the <code>@change</code> handler is fired <code>value</code> is updated. That is good. The problem is that when this value is updated vue rerenders the <code>slot</code>. That is exactly what you would want to happen and it does. The problem is that it does this by re-rendering the whole <code>component</code> not just the slot. You can test this out by putting anything else in the <code>component</code> and it get re-rendered too.</p>\n<div class=\"highlight highlight-text-html-basic\"><pre><span class=\"pl-kos\">&lt;</span><span class=\"pl-ent\">component</span><span class=\"pl-kos\">&gt;</span>\n  <span class=\"pl-kos\">&lt;</span><span class=\"pl-ent\">input</span> /&gt;\n  <span class=\"pl-kos\">&lt;</span><span class=\"pl-ent\">slot</span> <span class=\"pl-c1\">:value</span>=\"<span class=\"pl-s\">value</span>\" <span class=\"pl-c1\">@change</span>=\"<span class=\"pl-s\">v =&gt; value = v</span>\" /&gt;\n<span class=\"pl-kos\">&lt;/</span><span class=\"pl-ent\">component</span><span class=\"pl-kos\">&gt;</span></pre></div>\n<p>Set the focus to the <code>input</code> field and when <code>value</code> changes, you'll the focus leave the <code>input</code></p>", "createdAt": "2019-04-21T15:18:48Z", "publishedAt": "2019-04-21T15:18:48Z", "lastEditedAt": null, "updatedAt": "2019-04-21T15:18:48Z", "reactions": {"edges": [{"node": {"content": "THUMBS_UP", "createdAt": "2019-04-21T16:44:45Z"}}]}, "bodyParsed": [{"number": 4997, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "@LinusBorg, it is really quite simple if you have an component with a slot", "sentSegmented": ["linusborg", "it", "is", "really", "quite", "simple", "if", "you", "have", "an", "component", "with", "a", "slot"], "sentSegmentedWithoutStops": ["linusborg", "really", "quite", "simple", "component", "slot"], "sentSegmentedWithoutStopsStemmed": ["linusborg", "realli", "quit", "simpl", "compon", "slot"]}, {"number": 4998, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "<component>", "sentSegmented": ["component"], "sentSegmentedWithoutStops": ["component"], "sentSegmentedWithoutStopsStemmed": ["compon"]}, {"number": 4999, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "  <slot :value=\"value\" @change=\"v => value = v\" />", "sentSegmented": ["slot", "value=", "value", "change=", "v", "value", "v"], "sentSegmentedWithoutStops": ["slot", "value=", "value", "change=", "v", "value", "v"], "sentSegmentedWithoutStopsStemmed": ["slot", "value=", "valu", "change=", "v", "valu", "v"]}, {"number": 5000, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "component>", "sentSegmented": ["component"], "sentSegmentedWithoutStops": ["component"], "sentSegmentedWithoutStopsStemmed": ["compon"]}, {"number": 5001, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Whenever the @change handler is fired value is updated.", "sentSegmented": ["whenever", "the", "change", "handler", "is", "fired", "value", "is", "updated"], "sentSegmentedWithoutStops": ["whenever", "change", "handler", "fired", "value", "updated"], "sentSegmentedWithoutStopsStemmed": ["whenev", "chang", "handler", "fire", "valu", "updat"]}, {"number": 5002, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "That is good.", "sentSegmented": ["that", "is", "good"], "sentSegmentedWithoutStops": ["good"], "sentSegmentedWithoutStopsStemmed": ["good"]}, {"number": 5003, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "The problem is that when this value is updated vue rerenders the slot.", "sentSegmented": ["the", "problem", "is", "that", "when", "this", "value", "is", "updated", "vue", "rerenders", "the", "slot"], "sentSegmentedWithoutStops": ["problem", "value", "updated", "vue", "rerenders", "slot"], "sentSegmentedWithoutStopsStemmed": ["problem", "valu", "updat", "vue", "rerend", "slot"]}, {"number": 5004, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "That is exactly what you would want to happen and it does.", "sentSegmented": ["that", "is", "exactly", "what", "you", "would", "want", "to", "happen", "and", "it", "does"], "sentSegmentedWithoutStops": ["exactly", "would", "want", "happen"], "sentSegmentedWithoutStopsStemmed": ["exactli", "would", "want", "happen"]}, {"number": 5005, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "The problem is that it does this by re-rendering the whole component not just the slot.", "sentSegmented": ["the", "problem", "is", "that", "it", "does", "this", "by", "re-rendering", "the", "whole", "component", "not", "just", "the", "slot"], "sentSegmentedWithoutStops": ["problem", "re-rendering", "whole", "component", "slot"], "sentSegmentedWithoutStopsStemmed": ["problem", "re-rend", "whole", "compon", "slot"]}, {"number": 5006, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "You can test this out by putting anything else in the component and it get re-rendered too.", "sentSegmented": ["you", "can", "test", "this", "out", "by", "putting", "anything", "else", "in", "the", "component", "and", "it", "get", "re-rendered", "too"], "sentSegmentedWithoutStops": ["test", "putting", "anything", "else", "component", "get", "re-rendered"], "sentSegmentedWithoutStopsStemmed": ["test", "put", "anyth", "els", "compon", "get", "re-rend"]}, {"number": 5007, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "<component>", "sentSegmented": ["component"], "sentSegmentedWithoutStops": ["component"], "sentSegmentedWithoutStopsStemmed": ["compon"]}, {"number": 5008, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "  <input />", "sentSegmented": ["input"], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 5009, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "  <slot :value=\"value\" @change=\"v => value = v\" />", "sentSegmented": ["slot", "value=", "value", "change=", "v", "value", "v"], "sentSegmentedWithoutStops": ["slot", "value=", "value", "change=", "v", "value", "v"], "sentSegmentedWithoutStopsStemmed": ["slot", "value=", "valu", "change=", "v", "valu", "v"]}, {"number": 5010, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "component>", "sentSegmented": ["component"], "sentSegmentedWithoutStops": ["component"], "sentSegmentedWithoutStopsStemmed": ["compon"]}, {"number": 5011, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Set the focus to the input field and when value changes, you'll the focus leave the input", "sentSegmented": ["set", "the", "focus", "to", "the", "input", "field", "and", "when", "value", "changes", "you", "'ll", "the", "focus", "leave", "the", "input"], "sentSegmentedWithoutStops": ["set", "focus", "input", "field", "value", "changes", "'ll", "focus", "leave", "input"], "sentSegmentedWithoutStopsStemmed": ["set", "focu", "input", "field", "valu", "chang", "'ll", "focu", "leav", "input"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDQ4NTI2MzUzOA==", "author": {"login": "besnikh"}, "body": "@LinusBorg I can show you a live project where we are using a lot of `@change` on a v-text-field\r\n\r\n[Vetura Kosove](https://www.tepazari.com/posto-shpallje-falas/vetura/vetura-kosove)\r\n\r\nPS.\r\nThe language is Albanian but if you write in a good pc you will not notice a delay, but trying to write in input from a mobile (especially Android) will make typing a hell.\r\n\r\nCheers", "bodyText": "@LinusBorg I can show you a live project where we are using a lot of @change on a v-text-field\nVetura Kosove\nPS.\nThe language is Albanian but if you write in a good pc you will not notice a delay, but trying to write in input from a mobile (especially Android) will make typing a hell.\nCheers", "bodyHTML": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/LinusBorg/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/LinusBorg\">@LinusBorg</a> I can show you a live project where we are using a lot of <code>@change</code> on a v-text-field</p>\n<p><a href=\"https://www.tepazari.com/posto-shpallje-falas/vetura/vetura-kosove\" rel=\"nofollow\">Vetura Kosove</a></p>\n<p>PS.<br>\nThe language is Albanian but if you write in a good pc you will not notice a delay, but trying to write in input from a mobile (especially Android) will make typing a hell.</p>\n<p>Cheers</p>", "createdAt": "2019-04-21T16:11:30Z", "publishedAt": "2019-04-21T16:11:30Z", "lastEditedAt": "2019-04-21T16:19:55Z", "updatedAt": "2019-04-21T16:19:55Z", "reactions": {"edges": [{"node": {"content": "THUMBS_UP", "createdAt": "2019-04-21T16:44:43Z"}}, {"node": {"content": "THUMBS_UP", "createdAt": "2019-04-21T19:46:44Z"}}]}, "bodyParsed": [{"number": 5012, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "@LinusBorg I can show you a live project where we are using a lot of @change on a v-text-field", "sentSegmented": ["linusborg", "i", "can", "show", "you", "a", "live", "project", "where", "we", "are", "using", "a", "lot", "of", "change", "on", "a", "v-text-field"], "sentSegmentedWithoutStops": ["linusborg", "show", "live", "project", "using", "lot", "change", "v-text-field"], "sentSegmentedWithoutStopsStemmed": ["linusborg", "show", "live", "project", "use", "lot", "chang", "v-text-field"]}, {"number": 5013, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Vetura Kosove", "sentSegmented": ["vetura", "kosove"], "sentSegmentedWithoutStops": ["vetura", "kosove"], "sentSegmentedWithoutStopsStemmed": ["vetura", "kosov"]}, {"number": 5014, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "PS.", "sentSegmented": ["ps"], "sentSegmentedWithoutStops": ["ps"], "sentSegmentedWithoutStopsStemmed": ["ps"]}, {"number": 5015, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "The language is Albanian but if you write in a good pc you will not notice a delay, but trying to write in input from a mobile (especially Android) will make typing a hell.", "sentSegmented": ["the", "language", "is", "albanian", "but", "if", "you", "write", "in", "a", "good", "pc", "you", "will", "not", "notice", "a", "delay", "but", "trying", "to", "write", "in", "input", "from", "a", "mobile", "especially", "android", "will", "make", "typing", "a", "hell"], "sentSegmentedWithoutStops": ["language", "albanian", "write", "good", "pc", "notice", "delay", "trying", "write", "input", "mobile", "especially", "android", "make", "typing", "hell"], "sentSegmentedWithoutStopsStemmed": ["languag", "albanian", "write", "good", "pc", "notic", "delay", "tri", "write", "input", "mobil", "especi", "android", "make", "type", "hell"]}, {"number": 5016, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Cheers", "sentSegmented": ["cheers"], "sentSegmentedWithoutStops": ["cheers"], "sentSegmentedWithoutStopsStemmed": ["cheer"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDQ4NTI3NzcxMQ==", "author": {"login": "stygmate"}, "body": "> ..., but trying to write in input from a mobile (especially Android) will make typing a hell.\r\n\r\n@LinusBorg @besnikh exactly the same problem in my app !", "bodyText": "..., but trying to write in input from a mobile (especially Android) will make typing a hell.\n\n@LinusBorg @besnikh exactly the same problem in my app !", "bodyHTML": "<blockquote>\n<p>..., but trying to write in input from a mobile (especially Android) will make typing a hell.</p>\n</blockquote>\n<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/LinusBorg/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/LinusBorg\">@LinusBorg</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/besnikh/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/besnikh\">@besnikh</a> exactly the same problem in my app !</p>", "createdAt": "2019-04-21T19:48:08Z", "publishedAt": "2019-04-21T19:48:08Z", "lastEditedAt": "2019-04-21T20:10:33Z", "updatedAt": "2019-04-21T20:10:33Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 5017, "isCode": false, "isBlockQuote": true, "blockQuoteDepth": 1, "sent": "..., but trying to write in input from a mobile (especially Android) will make typing a hell.", "sentSegmented": ["but", "trying", "to", "write", "in", "input", "from", "a", "mobile", "especially", "android", "will", "make", "typing", "a", "hell"], "sentSegmentedWithoutStops": ["trying", "write", "input", "mobile", "especially", "android", "make", "typing", "hell"], "sentSegmentedWithoutStopsStemmed": ["tri", "write", "input", "mobil", "especi", "android", "make", "type", "hell"]}, {"number": 5018, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "@LinusBorg @besnikh exactly the same problem in my app !", "sentSegmented": ["linusborg", "besnikh", "exactly", "the", "same", "problem", "in", "my", "app"], "sentSegmentedWithoutStops": ["linusborg", "besnikh", "exactly", "problem", "app"], "sentSegmentedWithoutStopsStemmed": ["linusborg", "besnikh", "exactli", "problem", "app"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDQ4NTI3OTQ3Mg==", "author": {"login": "LinusBorg"}, "body": "I see what you mean but I don't really see a via able way to accomplish this except *not* using a virtualDOM, which means writing a new framework, essentially. \r\n\r\nYou find similar challenges in all vDom based frameworks (react etc.) - to update a slot he whole patent has to re-render in order to determine what to even send to the slot, that's determined by the render function. \r\n\r\nAnd nested slots that do a lot wig work on re-renders get expensive if the dependency that's being updated by e.g. an input is being provided by some distant ancestor-component.\r\n\r\nFor the framework that we have, we should rather investigate better patterns to compose our components in order to prevent these deep re-renders.", "bodyText": "I see what you mean but I don't really see a via able way to accomplish this except not using a virtualDOM, which means writing a new framework, essentially.\nYou find similar challenges in all vDom based frameworks (react etc.) - to update a slot he whole patent has to re-render in order to determine what to even send to the slot, that's determined by the render function.\nAnd nested slots that do a lot wig work on re-renders get expensive if the dependency that's being updated by e.g. an input is being provided by some distant ancestor-component.\nFor the framework that we have, we should rather investigate better patterns to compose our components in order to prevent these deep re-renders.", "bodyHTML": "<p>I see what you mean but I don't really see a via able way to accomplish this except <em>not</em> using a virtualDOM, which means writing a new framework, essentially.</p>\n<p>You find similar challenges in all vDom based frameworks (react etc.) - to update a slot he whole patent has to re-render in order to determine what to even send to the slot, that's determined by the render function.</p>\n<p>And nested slots that do a lot wig work on re-renders get expensive if the dependency that's being updated by e.g. an input is being provided by some distant ancestor-component.</p>\n<p>For the framework that we have, we should rather investigate better patterns to compose our components in order to prevent these deep re-renders.</p>", "createdAt": "2019-04-21T20:16:44Z", "publishedAt": "2019-04-21T20:16:44Z", "lastEditedAt": "2019-04-21T20:17:09Z", "updatedAt": "2019-04-21T20:17:09Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 5019, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "I see what you mean but I don't really see a via able way to accomplish this except not using a virtualDOM, which means writing a new framework, essentially.", "sentSegmented": ["i", "see", "what", "you", "mean", "but", "i", "do", "n't", "really", "see", "a", "via", "able", "way", "to", "accomplish", "this", "except", "not", "using", "a", "virtualdom", "which", "means", "writing", "a", "new", "framework", "essentially"], "sentSegmentedWithoutStops": ["see", "mean", "n't", "really", "see", "via", "able", "way", "accomplish", "except", "using", "virtualdom", "means", "writing", "new", "framework", "essentially"], "sentSegmentedWithoutStopsStemmed": ["see", "mean", "n't", "realli", "see", "via", "abl", "way", "accomplish", "except", "use", "virtualdom", "mean", "write", "new", "framework", "essenti"]}, {"number": 5020, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "You find similar challenges in all vDom based frameworks (react etc.)", "sentSegmented": ["you", "find", "similar", "challenges", "in", "all", "vdom", "based", "frameworks", "react", "etc"], "sentSegmentedWithoutStops": ["find", "similar", "challenges", "vdom", "based", "frameworks", "react", "etc"], "sentSegmentedWithoutStopsStemmed": ["find", "similar", "challeng", "vdom", "base", "framework", "react", "etc"]}, {"number": 5021, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "- to update a slot he whole patent has to re-render in order to determine what to even send to the slot, that's determined by the render function.", "sentSegmented": ["to", "update", "a", "slot", "he", "whole", "patent", "has", "to", "re-render", "in", "order", "to", "determine", "what", "to", "even", "send", "to", "the", "slot", "that", "'s", "determined", "by", "the", "render", "function"], "sentSegmentedWithoutStops": ["update", "slot", "whole", "patent", "re-render", "order", "determine", "even", "send", "slot", "'s", "determined", "render", "function"], "sentSegmentedWithoutStopsStemmed": ["updat", "slot", "whole", "patent", "re-rend", "order", "determin", "even", "send", "slot", "'s", "determin", "render", "function"]}, {"number": 5022, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "And nested slots that do a lot wig work on re-renders get expensive if the dependency that's being updated by e.g.", "sentSegmented": ["and", "nested", "slots", "that", "do", "a", "lot", "wig", "work", "on", "re-renders", "get", "expensive", "if", "the", "dependency", "that", "'s", "being", "updated", "by", "e.g"], "sentSegmentedWithoutStops": ["nested", "slots", "lot", "wig", "work", "re-renders", "get", "expensive", "dependency", "'s", "updated", "e.g"], "sentSegmentedWithoutStopsStemmed": ["nest", "slot", "lot", "wig", "work", "re-rend", "get", "expens", "depend", "'s", "updat", "e.g"]}, {"number": 5023, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "an input is being provided by some distant ancestor-component.", "sentSegmented": ["an", "input", "is", "being", "provided", "by", "some", "distant", "ancestor-component"], "sentSegmentedWithoutStops": ["input", "provided", "distant", "ancestor-component"], "sentSegmentedWithoutStopsStemmed": ["input", "provid", "distant", "ancestor-compon"]}, {"number": 5024, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "For the framework that we have, we should rather investigate better patterns to compose our components in order to prevent these deep re-renders.", "sentSegmented": ["for", "the", "framework", "that", "we", "have", "we", "should", "rather", "investigate", "better", "patterns", "to", "compose", "our", "components", "in", "order", "to", "prevent", "these", "deep", "re-renders"], "sentSegmentedWithoutStops": ["framework", "rather", "investigate", "better", "patterns", "compose", "components", "order", "prevent", "deep", "re-renders"], "sentSegmentedWithoutStopsStemmed": ["framework", "rather", "investig", "better", "pattern", "compos", "compon", "order", "prevent", "deep", "re-rend"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDQ4NTI4MjM0Mw==", "author": {"login": "wparad"}, "body": "@LinusBorg I'm not an expert in virtual DOMs, so I'm interested in doing a 5 whys here: \r\n>  to update a slot he whole patent has to re-render in order to determine what to even send to the slot, that's determined by the render function.\r\n\r\nWhy? What's the importance of it being a slot? If it wasn't a slot it would work correctly, and the resultant html and javascript look the same.  The parent would get the updated property intentionally and then the child would be afterwards. However, we know something, we know that this isn't a property changing, instead we know it is a slot changing. Soooo....\r\n\r\nI'm going to say something that is probably dumb:\r\n* Why don't we just wrap the slot in a component and treat it as a component that has inputs passed in:\r\ni.e.\r\n```html\r\n<component :props=\"parent\">\r\n  <slot-component :props=\"parent + child\">\r\n    <input>\r\n  </slot-component>\r\n<component>\r\n```\r\nbut instead of those inputs `parent` here being edit which cause the component to rerender, bypass re-rendering the `component` and just pass those same props to the `slot-component`.  Since we know it is a slot what could possibly make the `component` need to re-render?", "bodyText": "@LinusBorg I'm not an expert in virtual DOMs, so I'm interested in doing a 5 whys here:\n\nto update a slot he whole patent has to re-render in order to determine what to even send to the slot, that's determined by the render function.\n\nWhy? What's the importance of it being a slot? If it wasn't a slot it would work correctly, and the resultant html and javascript look the same.  The parent would get the updated property intentionally and then the child would be afterwards. However, we know something, we know that this isn't a property changing, instead we know it is a slot changing. Soooo....\nI'm going to say something that is probably dumb:\n\nWhy don't we just wrap the slot in a component and treat it as a component that has inputs passed in:\ni.e.\n\n<component :props=\"parent\">\n  <slot-component :props=\"parent + child\">\n    <input>\n  </slot-component>\n<component>\nbut instead of those inputs parent here being edit which cause the component to rerender, bypass re-rendering the component and just pass those same props to the slot-component.  Since we know it is a slot what could possibly make the component need to re-render?", "bodyHTML": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/LinusBorg/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/LinusBorg\">@LinusBorg</a> I'm not an expert in virtual DOMs, so I'm interested in doing a 5 whys here:</p>\n<blockquote>\n<p>to update a slot he whole patent has to re-render in order to determine what to even send to the slot, that's determined by the render function.</p>\n</blockquote>\n<p>Why? What's the importance of it being a slot? If it wasn't a slot it would work correctly, and the resultant html and javascript look the same.  The parent would get the updated property intentionally and then the child would be afterwards. However, we know something, we know that this isn't a property changing, instead we know it is a slot changing. Soooo....</p>\n<p>I'm going to say something that is probably dumb:</p>\n<ul>\n<li>Why don't we just wrap the slot in a component and treat it as a component that has inputs passed in:<br>\ni.e.</li>\n</ul>\n<div class=\"highlight highlight-text-html-basic\"><pre><span class=\"pl-kos\">&lt;</span><span class=\"pl-ent\">component</span> <span class=\"pl-c1\">:props</span>=\"<span class=\"pl-s\">parent</span>\"<span class=\"pl-kos\">&gt;</span>\n  <span class=\"pl-kos\">&lt;</span><span class=\"pl-ent\">slot-component</span> <span class=\"pl-c1\">:props</span>=\"<span class=\"pl-s\">parent + child</span>\"<span class=\"pl-kos\">&gt;</span>\n    <span class=\"pl-kos\">&lt;</span><span class=\"pl-ent\">input</span><span class=\"pl-kos\">&gt;</span>\n  <span class=\"pl-kos\">&lt;/</span><span class=\"pl-ent\">slot-component</span><span class=\"pl-kos\">&gt;</span>\n<span class=\"pl-kos\">&lt;</span><span class=\"pl-ent\">component</span><span class=\"pl-kos\">&gt;</span></pre></div>\n<p>but instead of those inputs <code>parent</code> here being edit which cause the component to rerender, bypass re-rendering the <code>component</code> and just pass those same props to the <code>slot-component</code>.  Since we know it is a slot what could possibly make the <code>component</code> need to re-render?</p>", "createdAt": "2019-04-21T21:05:38Z", "publishedAt": "2019-04-21T21:05:38Z", "lastEditedAt": "2019-04-21T21:07:45Z", "updatedAt": "2019-04-21T21:07:45Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 5025, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "@LinusBorg I'm not an expert in virtual DOMs, so I'm interested in doing a 5 whys here:", "sentSegmented": ["linusborg", "i", "'m", "not", "an", "expert", "in", "virtual", "doms", "so", "i", "'m", "interested", "in", "doing", "a", "5", "whys", "here"], "sentSegmentedWithoutStops": ["linusborg", "'m", "expert", "virtual", "doms", "'m", "interested", "5", "whys"], "sentSegmentedWithoutStopsStemmed": ["linusborg", "'m", "expert", "virtual", "dom", "'m", "interest", "5", "whi"]}, {"number": 5026, "isCode": false, "isBlockQuote": true, "blockQuoteDepth": 1, "sent": "to update a slot he whole patent has to re-render in order to determine what to even send to the slot, that's determined by the render function.", "sentSegmented": ["to", "update", "a", "slot", "he", "whole", "patent", "has", "to", "re-render", "in", "order", "to", "determine", "what", "to", "even", "send", "to", "the", "slot", "that", "'s", "determined", "by", "the", "render", "function"], "sentSegmentedWithoutStops": ["update", "slot", "whole", "patent", "re-render", "order", "determine", "even", "send", "slot", "'s", "determined", "render", "function"], "sentSegmentedWithoutStopsStemmed": ["updat", "slot", "whole", "patent", "re-rend", "order", "determin", "even", "send", "slot", "'s", "determin", "render", "function"]}, {"number": 5027, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Why?", "sentSegmented": ["why"], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 5028, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "What's the importance of it being a slot?", "sentSegmented": ["what", "'s", "the", "importance", "of", "it", "being", "a", "slot"], "sentSegmentedWithoutStops": ["'s", "importance", "slot"], "sentSegmentedWithoutStopsStemmed": ["'s", "import", "slot"]}, {"number": 5029, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "If it wasn't a slot it would work correctly, and the resultant html and javascript look the same.", "sentSegmented": ["if", "it", "was", "n't", "a", "slot", "it", "would", "work", "correctly", "and", "the", "resultant", "html", "and", "javascript", "look", "the", "same"], "sentSegmentedWithoutStops": ["n't", "slot", "would", "work", "correctly", "resultant", "html", "javascript", "look"], "sentSegmentedWithoutStopsStemmed": ["n't", "slot", "would", "work", "correctli", "result", "html", "javascript", "look"]}, {"number": 5030, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "The parent would get the updated property intentionally and then the child would be afterwards.", "sentSegmented": ["the", "parent", "would", "get", "the", "updated", "property", "intentionally", "and", "then", "the", "child", "would", "be", "afterwards"], "sentSegmentedWithoutStops": ["parent", "would", "get", "updated", "property", "intentionally", "child", "would", "afterwards"], "sentSegmentedWithoutStopsStemmed": ["parent", "would", "get", "updat", "properti", "intent", "child", "would", "afterward"]}, {"number": 5031, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "However, we know something, we know that this isn't a property changing, instead we know it is a slot changing.", "sentSegmented": ["however", "we", "know", "something", "we", "know", "that", "this", "is", "n't", "a", "property", "changing", "instead", "we", "know", "it", "is", "a", "slot", "changing"], "sentSegmentedWithoutStops": ["however", "know", "something", "know", "n't", "property", "changing", "instead", "know", "slot", "changing"], "sentSegmentedWithoutStopsStemmed": ["howev", "know", "someth", "know", "n't", "properti", "chang", "instead", "know", "slot", "chang"]}, {"number": 5032, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Soooo....", "sentSegmented": ["soooo"], "sentSegmentedWithoutStops": ["soooo"], "sentSegmentedWithoutStopsStemmed": ["soooo"]}, {"number": 5033, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "I'm going to say something that is probably dumb:", "sentSegmented": ["i", "'m", "going", "to", "say", "something", "that", "is", "probably", "dumb"], "sentSegmentedWithoutStops": ["'m", "going", "say", "something", "probably", "dumb"], "sentSegmentedWithoutStopsStemmed": ["'m", "go", "say", "someth", "probabl", "dumb"]}, {"number": 5034, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Why don't we just wrap the slot in a component and treat it as a component that has inputs passed in:", "sentSegmented": ["why", "do", "n't", "we", "just", "wrap", "the", "slot", "in", "a", "component", "and", "treat", "it", "as", "a", "component", "that", "has", "inputs", "passed", "in"], "sentSegmentedWithoutStops": ["n't", "wrap", "slot", "component", "treat", "component", "inputs", "passed"], "sentSegmentedWithoutStopsStemmed": ["n't", "wrap", "slot", "compon", "treat", "compon", "input", "pass"]}, {"number": 5035, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "i.e.", "sentSegmented": ["i.e"], "sentSegmentedWithoutStops": ["i.e"], "sentSegmentedWithoutStopsStemmed": ["i.e"]}, {"number": 5036, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "<component :props=\"parent\">", "sentSegmented": ["component", "props=", "parent"], "sentSegmentedWithoutStops": ["component", "props=", "parent"], "sentSegmentedWithoutStopsStemmed": ["compon", "props=", "parent"]}, {"number": 5037, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "  <slot-component :props=\"parent + child\">", "sentSegmented": ["slot-component", "props=", "parent", "child"], "sentSegmentedWithoutStops": ["slot-component", "props=", "parent", "child"], "sentSegmentedWithoutStopsStemmed": ["slot-compon", "props=", "parent", "child"]}, {"number": 5038, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "    <input>", "sentSegmented": ["input"], "sentSegmentedWithoutStops": [], "sentSegmentedWithoutStopsStemmed": []}, {"number": 5039, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "  slot-component>", "sentSegmented": ["slot-component"], "sentSegmentedWithoutStops": ["slot-component"], "sentSegmentedWithoutStopsStemmed": ["slot-compon"]}, {"number": 5040, "isCode": true, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "<component>", "sentSegmented": ["component"], "sentSegmentedWithoutStops": ["component"], "sentSegmentedWithoutStopsStemmed": ["compon"]}, {"number": 5041, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "but instead of those inputs parent here being edit which cause the component to rerender, bypass re-rendering the component and just pass those same props to the slot-component.", "sentSegmented": ["but", "instead", "of", "those", "inputs", "parent", "here", "being", "edit", "which", "cause", "the", "component", "to", "rerender", "bypass", "re-rendering", "the", "component", "and", "just", "pass", "those", "same", "props", "to", "the", "slot-component"], "sentSegmentedWithoutStops": ["instead", "inputs", "parent", "edit", "cause", "component", "rerender", "bypass", "re-rendering", "component", "pass", "props", "slot-component"], "sentSegmentedWithoutStopsStemmed": ["instead", "input", "parent", "edit", "caus", "compon", "rerend", "bypass", "re-rend", "compon", "pass", "prop", "slot-compon"]}, {"number": 5042, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Since we know it is a slot what could possibly make the component need to re-render?", "sentSegmented": ["since", "we", "know", "it", "is", "a", "slot", "what", "could", "possibly", "make", "the", "component", "need", "to", "re-render"], "sentSegmentedWithoutStops": ["since", "know", "slot", "could", "possibly", "make", "component", "need", "re-render"], "sentSegmentedWithoutStopsStemmed": ["sinc", "know", "slot", "could", "possibl", "make", "compon", "need", "re-rend"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDQ4NTI4NTc5Ng==", "author": {"login": "LinusBorg"}, "body": "I'll answer aboutbrh why tomorrow, it's 1am here. \r\n\r\n But as I see a risk of us  talking past each other I would *still* be thankful for an actually runnable example clearly demonstrating your issue instead of 3 lines from above. \r\n\r\nThe thing about the focus is clearly not the performance issue we are discussing here... ", "bodyText": "I'll answer aboutbrh why tomorrow, it's 1am here.\nBut as I see a risk of us  talking past each other I would still be thankful for an actually runnable example clearly demonstrating your issue instead of 3 lines from above.\nThe thing about the focus is clearly not the performance issue we are discussing here...", "bodyHTML": "<p>I'll answer aboutbrh why tomorrow, it's 1am here.</p>\n<p>But as I see a risk of us  talking past each other I would <em>still</em> be thankful for an actually runnable example clearly demonstrating your issue instead of 3 lines from above.</p>\n<p>The thing about the focus is clearly not the performance issue we are discussing here...</p>", "createdAt": "2019-04-21T22:08:09Z", "publishedAt": "2019-04-21T22:08:09Z", "lastEditedAt": "2019-04-21T22:09:10Z", "updatedAt": "2019-04-21T22:09:10Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 5043, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "I'll answer aboutbrh why tomorrow, it's 1am here.", "sentSegmented": ["i", "'ll", "answer", "aboutbrh", "why", "tomorrow", "it", "'s", "1am", "here"], "sentSegmentedWithoutStops": ["'ll", "answer", "aboutbrh", "tomorrow", "'s", "1am"], "sentSegmentedWithoutStopsStemmed": ["'ll", "answer", "aboutbrh", "tomorrow", "'s", "1am"]}, {"number": 5044, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "But as I see a risk of us  talking past each other I would still be thankful for an actually runnable example clearly demonstrating your issue instead of 3 lines from above.", "sentSegmented": ["but", "as", "i", "see", "a", "risk", "of", "us", "talking", "past", "each", "other", "i", "would", "still", "be", "thankful", "for", "an", "actually", "runnable", "example", "clearly", "demonstrating", "your", "issue", "instead", "of", "3", "lines", "from", "above"], "sentSegmentedWithoutStops": ["see", "risk", "us", "talking", "past", "would", "still", "thankful", "actually", "runnable", "example", "clearly", "demonstrating", "issue", "instead", "3", "lines"], "sentSegmentedWithoutStopsStemmed": ["see", "risk", "us", "talk", "past", "would", "still", "thank", "actual", "runnabl", "exampl", "clearli", "demonstr", "issu", "instead", "3", "line"]}, {"number": 5045, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "The thing about the focus is clearly not the performance issue we are discussing here...", "sentSegmented": ["the", "thing", "about", "the", "focus", "is", "clearly", "not", "the", "performance", "issue", "we", "are", "discussing", "here"], "sentSegmentedWithoutStops": ["thing", "focus", "clearly", "performance", "issue", "discussing"], "sentSegmentedWithoutStopsStemmed": ["thing", "focu", "clearli", "perform", "issu", "discuss"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDQ4NTI4ODc4Mg==", "author": {"login": "adamvleggett"}, "body": "Solving this seems to require decoupling the scope of rendering from the scope of a component. This will be coming with Vue 3, I think it is highly unlikely in Vue 2.", "bodyText": "Solving this seems to require decoupling the scope of rendering from the scope of a component. This will be coming with Vue 3, I think it is highly unlikely in Vue 2.", "bodyHTML": "<p>Solving this seems to require decoupling the scope of rendering from the scope of a component. This will be coming with Vue 3, I think it is highly unlikely in Vue 2.</p>", "createdAt": "2019-04-21T23:05:40Z", "publishedAt": "2019-04-21T23:05:40Z", "lastEditedAt": null, "updatedAt": "2019-04-21T23:05:40Z", "reactions": {"edges": [{"node": {"content": "THUMBS_UP", "createdAt": "2019-07-11T06:19:10Z"}}, {"node": {"content": "THUMBS_UP", "createdAt": "2019-09-07T10:06:22Z"}}]}, "bodyParsed": [{"number": 5046, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Solving this seems to require decoupling the scope of rendering from the scope of a component.", "sentSegmented": ["solving", "this", "seems", "to", "require", "decoupling", "the", "scope", "of", "rendering", "from", "the", "scope", "of", "a", "component"], "sentSegmentedWithoutStops": ["solving", "seems", "require", "decoupling", "scope", "rendering", "scope", "component"], "sentSegmentedWithoutStopsStemmed": ["solv", "seem", "requir", "decoupl", "scope", "render", "scope", "compon"]}, {"number": 5047, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "This will be coming with Vue 3, I think it is highly unlikely in Vue 2.", "sentSegmented": ["this", "will", "be", "coming", "with", "vue", "3", "i", "think", "it", "is", "highly", "unlikely", "in", "vue", "2"], "sentSegmentedWithoutStops": ["coming", "vue", "3", "think", "highly", "unlikely", "vue", "2"], "sentSegmentedWithoutStopsStemmed": ["come", "vue", "3", "think", "highli", "unlik", "vue", "2"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDcxNzgxMTc1MA==", "author": {"login": "mesihtasci"}, "body": "Is this fixed now in vue 3? @adamvleggett ", "bodyText": "Is this fixed now in vue 3? @adamvleggett", "bodyHTML": "<p>Is this fixed now in vue 3? <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/adamvleggett/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/adamvleggett\">@adamvleggett</a></p>", "createdAt": "2020-10-28T09:33:03Z", "publishedAt": "2020-10-28T09:33:03Z", "lastEditedAt": null, "updatedAt": "2020-10-28T09:33:03Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 5048, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Is this fixed now in vue 3?", "sentSegmented": ["is", "this", "fixed", "now", "in", "vue", "3"], "sentSegmentedWithoutStops": ["fixed", "vue", "3"], "sentSegmentedWithoutStopsStemmed": ["fix", "vue", "3"]}, {"number": 5049, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "@adamvleggett", "sentSegmented": ["adamvleggett"], "sentSegmentedWithoutStops": ["adamvleggett"], "sentSegmentedWithoutStopsStemmed": ["adamvleggett"]}]}}, {"node": {"id": "MDEyOklzc3VlQ29tbWVudDcxNzgxNzk3MA==", "author": {"login": "LinusBorg"}, "body": "Aside from the optimizations we already introduced to Vue 2 with `v-slot`: No. \r\n\r\nVirtualDOM implementations rely on this behavior in general. Vue 3 is no different.\r\n\r\nVue 3 might offer improvements in terms of performance as we now only need to re-render and diff vDOM for dynamic elements - if you generate large structured of static HTML, those can now be ignored by the renderer due to compiler optimizations.", "bodyText": "Aside from the optimizations we already introduced to Vue 2 with v-slot: No.\nVirtualDOM implementations rely on this behavior in general. Vue 3 is no different.\nVue 3 might offer improvements in terms of performance as we now only need to re-render and diff vDOM for dynamic elements - if you generate large structured of static HTML, those can now be ignored by the renderer due to compiler optimizations.", "bodyHTML": "<p>Aside from the optimizations we already introduced to Vue 2 with <code>v-slot</code>: No.</p>\n<p>VirtualDOM implementations rely on this behavior in general. Vue 3 is no different.</p>\n<p>Vue 3 might offer improvements in terms of performance as we now only need to re-render and diff vDOM for dynamic elements - if you generate large structured of static HTML, those can now be ignored by the renderer due to compiler optimizations.</p>", "createdAt": "2020-10-28T09:45:07Z", "publishedAt": "2020-10-28T09:45:07Z", "lastEditedAt": "2020-10-28T09:46:26Z", "updatedAt": "2020-10-28T09:46:26Z", "reactions": {"edges": []}, "bodyParsed": [{"number": 5050, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Aside from the optimizations we already introduced to Vue 2 with v-slot: No.", "sentSegmented": ["aside", "from", "the", "optimizations", "we", "already", "introduced", "to", "vue", "2", "with", "v-slot", "no"], "sentSegmentedWithoutStops": ["aside", "optimizations", "already", "introduced", "vue", "2", "v-slot"], "sentSegmentedWithoutStopsStemmed": ["asid", "optim", "alreadi", "introduc", "vue", "2", "v-slot"]}, {"number": 5051, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "VirtualDOM implementations rely on this behavior in general.", "sentSegmented": ["virtualdom", "implementations", "rely", "on", "this", "behavior", "in", "general"], "sentSegmentedWithoutStops": ["virtualdom", "implementations", "rely", "behavior", "general"], "sentSegmentedWithoutStopsStemmed": ["virtualdom", "implement", "reli", "behavior", "gener"]}, {"number": 5052, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Vue 3 is no different.", "sentSegmented": ["vue", "3", "is", "no", "different"], "sentSegmentedWithoutStops": ["vue", "3", "different"], "sentSegmentedWithoutStopsStemmed": ["vue", "3", "differ"]}, {"number": 5053, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Vue 3 might offer improvements in terms of performance as we now only need to re-render and diff vDOM for dynamic elements - if you generate large structured of static HTML, those can now be ignored by the renderer due to compiler optimizations.", "sentSegmented": ["vue", "3", "might", "offer", "improvements", "in", "terms", "of", "performance", "as", "we", "now", "only", "need", "to", "re-render", "and", "diff", "vdom", "for", "dynamic", "elements", "if", "you", "generate", "large", "structured", "of", "static", "html", "those", "can", "now", "be", "ignored", "by", "the", "renderer", "due", "to", "compiler", "optimizations"], "sentSegmentedWithoutStops": ["vue", "3", "might", "offer", "improvements", "terms", "performance", "need", "re-render", "diff", "vdom", "dynamic", "elements", "generate", "large", "structured", "static", "html", "ignored", "renderer", "due", "compiler", "optimizations"], "sentSegmentedWithoutStopsStemmed": ["vue", "3", "might", "offer", "improv", "term", "perform", "need", "re-rend", "diff", "vdom", "dynam", "element", "gener", "larg", "structur", "static", "html", "ignor", "render", "due", "compil", "optim"]}]}}], "pageInfo": {"endCursor": "Y3Vyc29yOnYyOpHOHOwOeA==", "hasNextPage": true}, "totalCount": 30}, "labels": {"edges": [{"node": {"createdAt": "2016-01-26T15:45:10Z", "name": "improvement"}}]}, "milestone": null, "reactions": {"edges": [{"node": {"content": "THUMBS_UP", "createdAt": "2017-10-28T06:35:37Z"}}, {"node": {"content": "THUMBS_UP", "createdAt": "2018-04-13T10:13:02Z"}}, {"node": {"content": "THUMBS_UP", "createdAt": "2019-01-25T16:10:30Z"}}, {"node": {"content": "THUMBS_UP", "createdAt": "2019-03-01T22:31:58Z"}}, {"node": {"content": "THUMBS_UP", "createdAt": "2019-07-01T14:42:09Z"}}, {"node": {"content": "THUMBS_UP", "createdAt": "2019-09-17T20:05:56Z"}}, {"node": {"content": "THUMBS_UP", "createdAt": "2019-10-31T19:22:34Z"}}, {"node": {"content": "THUMBS_UP", "createdAt": "2019-12-01T19:13:02Z"}}, {"node": {"content": "THUMBS_UP", "createdAt": "2020-04-17T02:35:17Z"}}, {"node": {"content": "THUMBS_UP", "createdAt": "2020-10-07T20:44:59Z"}}]}, "state": "OPEN", "titleSegmented": ["update", "slot", "content", "without", "rerendering", "rest", "of", "component"], "titleSegmentedWithoutStops": ["update", "slot", "content", "without", "rerendering", "rest", "component"], "titleSegmentedWithoutStopsStemmed": ["updat", "slot", "content", "without", "rerend", "rest", "compon"], "bodyParsed": [{"number": 4896, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "What problem does this feature solve?", "sentSegmented": ["what", "problem", "does", "this", "feature", "solve"], "sentSegmentedWithoutStops": ["problem", "feature", "solve"], "sentSegmentedWithoutStopsStemmed": ["problem", "featur", "solv"]}, {"number": 4897, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "I have developed some components that can generate large amounts of HTML, and allow content to be added via slot.", "sentSegmented": ["i", "have", "developed", "some", "components", "that", "can", "generate", "large", "amounts", "of", "html", "and", "allow", "content", "to", "be", "added", "via", "slot"], "sentSegmentedWithoutStops": ["developed", "components", "generate", "large", "amounts", "html", "allow", "content", "added", "via", "slot"], "sentSegmentedWithoutStopsStemmed": ["develop", "compon", "gener", "larg", "amount", "html", "allow", "content", "ad", "via", "slot"]}, {"number": 4898, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "It appears that if the slot content is updated, the render function is called for the component; however, this seems like something that could be avoided through optimization which would significantly improve the performance of my component in some instances.", "sentSegmented": ["it", "appears", "that", "if", "the", "slot", "content", "is", "updated", "the", "render", "function", "is", "called", "for", "the", "component", "however", "this", "seems", "like", "something", "that", "could", "be", "avoided", "through", "optimization", "which", "would", "significantly", "improve", "the", "performance", "of", "my", "component", "in", "some", "instances"], "sentSegmentedWithoutStops": ["appears", "slot", "content", "updated", "render", "function", "called", "component", "however", "seems", "like", "something", "could", "avoided", "optimization", "would", "significantly", "improve", "performance", "component", "instances"], "sentSegmentedWithoutStopsStemmed": ["appear", "slot", "content", "updat", "render", "function", "call", "compon", "howev", "seem", "like", "someth", "could", "avoid", "optim", "would", "significantli", "improv", "perform", "compon", "instanc"]}, {"number": 4899, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Is this possible?", "sentSegmented": ["is", "this", "possible"], "sentSegmentedWithoutStops": ["possible"], "sentSegmentedWithoutStopsStemmed": ["possibl"]}, {"number": 4900, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "What does the proposed API look like?", "sentSegmented": ["what", "does", "the", "proposed", "api", "look", "like"], "sentSegmentedWithoutStops": ["proposed", "api", "look", "like"], "sentSegmentedWithoutStopsStemmed": ["propos", "api", "look", "like"]}, {"number": 4901, "isCode": false, "isBlockQuote": false, "blockQuoteDepth": 0, "sent": "Not proposing API changes.", "sentSegmented": ["not", "proposing", "api", "changes"], "sentSegmentedWithoutStops": ["proposing", "api", "changes"], "sentSegmentedWithoutStopsStemmed": ["propos", "api", "chang"]}]}